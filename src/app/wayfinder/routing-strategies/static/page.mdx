export const metadata = {
  title: 'StaticRoutingStrategy',
  description:
    'A routing strategy that always returns the same configured gateway, ignoring provided gateway lists.',
  openGraph: {
    title: 'StaticRoutingStrategy',
  },
}

# StaticRoutingStrategy

A routing strategy that always returns the same configured gateway, ignoring provided gateway lists.

## Overview

The `StaticRoutingStrategy` is the simplest routing strategy that always returns a single, pre-configured gateway URL. This strategy ignores any gateways provided by the `GatewaysProvider` and is useful for scenarios where you want to force all requests to use a specific gateway.

## Constructor

```typescript
new StaticRoutingStrategy({
  gateway: string,
  logger?: Logger
})
```

### Parameters

- **`gateway`** (`string`): The gateway URL to always use (will be converted to URL object)
- **`logger`** (`Logger`, optional): Custom logger instance

## Examples

### Basic Usage

```javascript
import {
  StaticRoutingStrategy,
  Wayfinder,
  NetworkGatewaysProvider,
} from '@ar.io/wayfinder-core'
import { ARIO } from '@ar.io/sdk'

// Always use arweave.net
const staticStrategy = new StaticRoutingStrategy({
  gateway: 'https://arweave.net',
})

const wayfinder = new Wayfinder({
  gatewaysProvider: new NetworkGatewaysProvider({
    ario: ARIO.mainnet(),
  }),
  routingSettings: {
    strategy: staticStrategy,
  },
})

// All requests will use arweave.net regardless of available gateways
const response = await wayfinder.request('ar://ardrive')
```

### With Custom Gateway

```javascript
import { StaticRoutingStrategy } from '@ar.io/wayfinder-core'

// Use a specific gateway
const permagateStrategy = new StaticRoutingStrategy({
  gateway: 'https://permagate.io',
})

// Use a custom gateway
const customStrategy = new StaticRoutingStrategy({
  gateway: 'https://my-custom-gateway.com',
})

// Use a gateway with custom port
const localStrategy = new StaticRoutingStrategy({
  gateway: 'http://localhost:1984',
})
```

### With Custom Logger

```javascript
const logger = {
  debug: (msg, data) => console.debug(`[STATIC] ${msg}`, data),
  info: (msg, data) => console.info(`[STATIC] ${msg}`, data),
  warn: (msg, data) => console.warn(`[STATIC] ${msg}`, data),
  error: (msg, data) => console.error(`[STATIC] ${msg}`, data),
}

const staticStrategy = new StaticRoutingStrategy({
  gateway: 'https://arweave.net',
  logger,
})
```

### Development Environment

```javascript
// Use local gateway for development
const devStrategy = new StaticRoutingStrategy({
  gateway: 'http://localhost:1984',
})

const wayfinder = new Wayfinder({
  gatewaysProvider: new NetworkGatewaysProvider({
    ario: ARIO.mainnet(),
  }),
  routingSettings: {
    strategy: devStrategy,
  },
})
```

## Behavior

### Gateway Selection

The strategy always returns the configured gateway:

```javascript
const strategy = new StaticRoutingStrategy({
  gateway: 'https://permagate.io',
})

// Returns https://permagate.io regardless of input
const gateway1 = await strategy.selectGateway({
  gateways: [new URL('https://arweave.net'), new URL('https://g8way.io')],
})
console.log(gateway1.toString()) // https://permagate.io

// Still returns https://permagate.io
const gateway2 = await strategy.selectGateway({ gateways: [] })
console.log(gateway2.toString()) // https://permagate.io
```

### Ignoring Provided Gateways

When gateways are provided, they are ignored with a warning:

```javascript
const strategy = new StaticRoutingStrategy({
  gateway: 'https://arweave.net',
  logger: {
    warn: (msg, data) => console.log('Warning:', msg, data),
    // ... other logger methods
  },
})

await strategy.selectGateway({
  gateways: [new URL('https://permagate.io')],
})
// Logs: "Warning: StaticRoutingStrategy does not accept provided gateways..."
```

## Use Cases

### Dedicated Gateway

```javascript
// Always use your organization's dedicated gateway
const dedicatedStrategy = new StaticRoutingStrategy({
  gateway: 'https://gateway.mycompany.com',
})
```

### Testing and Development

```javascript
// Test against a specific gateway
const testStrategy = new StaticRoutingStrategy({
  gateway: 'https://testnet-gateway.ar.io',
})

// Local development
const localStrategy = new StaticRoutingStrategy({
  gateway: 'http://localhost:1984',
})
```

### Compliance and Control

```javascript
// Ensure all requests go through approved gateway
const complianceStrategy = new StaticRoutingStrategy({
  gateway: 'https://approved-gateway.enterprise.com',
})
```

### Fallback Strategy

```javascript
import {
  StaticRoutingStrategy,
  PreferredWithFallbackRoutingStrategy,
  FastestPingRoutingStrategy,
} from '@ar.io/wayfinder-core'

// Use static strategy as final fallback
const strategyWithStaticFallback = new PreferredWithFallbackRoutingStrategy({
  preferredGateway: new URL('https://primary.gateway.com'),
  fallbackStrategy: new StaticRoutingStrategy({
    gateway: 'https://backup.gateway.com',
  }),
})
```

## Configuration Examples

### Environment-Based Configuration

```javascript
const getGatewayForEnvironment = () => {
  switch (process.env.NODE_ENV) {
    case 'development':
      return 'http://localhost:1984'
    case 'staging':
      return 'https://staging-gateway.ar.io'
    case 'production':
      return 'https://arweave.net'
    default:
      return 'https://arweave.net'
  }
}

const strategy = new StaticRoutingStrategy({
  gateway: getGatewayForEnvironment(),
})
```

### Regional Gateways

```javascript
// Select gateway based on region
const getRegionalGateway = (region) => {
  const gateways = {
    'us-east': 'https://us-east.gateway.com',
    'us-west': 'https://us-west.gateway.com',
    eu: 'https://eu.gateway.com',
    asia: 'https://asia.gateway.com',
  }
  return gateways[region] || 'https://arweave.net'
}

const strategy = new StaticRoutingStrategy({
  gateway: getRegionalGateway('us-east'),
})
```

### Load Balancer Gateway

```javascript
// Use a load balancer that distributes across multiple gateways
const loadBalancerStrategy = new StaticRoutingStrategy({
  gateway: 'https://lb.gateways.com', // Load balancer handles distribution
})
```

## Performance Characteristics

### Advantages

- **Fastest selection**: No network requests or computations
- **Predictable**: Always returns the same gateway
- **Simple**: Minimal configuration required
- **Reliable**: No dependency on external gateway discovery

### Considerations

- **No redundancy**: Single point of failure
- **No optimization**: Doesn't adapt to gateway performance
- **Limited flexibility**: Cannot route based on content or location

## Performance Comparison

```javascript
import { performance } from 'perf_hooks'

// Static strategy - instant selection
const staticStrategy = new StaticRoutingStrategy({
  gateway: 'https://arweave.net',
})

const start = performance.now()
const gateway = await staticStrategy.selectGateway({ gateways })
const time = performance.now() - start
console.log(`Static selection: ${time.toFixed(2)}ms`) // ~0.01ms

// Compare with ping-based strategy
const pingStrategy = new FastestPingRoutingStrategy()
const pingStart = performance.now()
const pingGateway = await pingStrategy.selectGateway({ gateways })
const pingTime = performance.now() - pingStart
console.log(`Ping selection: ${pingTime.toFixed(2)}ms`) // ~500-2000ms
```

## Monitoring and Debugging

### Gateway Usage Tracking

```javascript
let requestCount = 0

const strategy = new StaticRoutingStrategy({
  gateway: 'https://arweave.net',
  logger: {
    debug: (msg, data) => {
      requestCount++
      console.log(`Request #${requestCount} using static gateway`)
    },
    info: console.info,
    warn: console.warn,
    error: console.error,
  },
})
```

### Health Monitoring

```javascript
// Monitor the health of your static gateway
const monitorGatewayHealth = async (gatewayUrl) => {
  try {
    const response = await fetch(`${gatewayUrl}/info`, {
      method: 'HEAD',
      timeout: 5000,
    })
    return response.ok
  } catch (error) {
    return false
  }
}

const strategy = new StaticRoutingStrategy({
  gateway: 'https://arweave.net',
})

// Periodically check gateway health
setInterval(async () => {
  const isHealthy = await monitorGatewayHealth('https://arweave.net')
  console.log(`Gateway health: ${isHealthy ? 'OK' : 'FAILED'}`)
}, 60000) // Check every minute
```

## Integration Patterns

### With Circuit Breaker

```javascript
class CircuitBreakerStaticStrategy {
  constructor({ gateway, failureThreshold = 5, resetTimeoutMs = 60000 }) {
    this.strategy = new StaticRoutingStrategy({ gateway })
    this.failureCount = 0
    this.failureThreshold = failureThreshold
    this.resetTimeoutMs = resetTimeoutMs
    this.lastFailureTime = 0
    this.isOpen = false
  }

  async selectGateway(params) {
    if (this.isOpen) {
      if (Date.now() - this.lastFailureTime > this.resetTimeoutMs) {
        this.isOpen = false
        this.failureCount = 0
      } else {
        throw new Error('Circuit breaker is open')
      }
    }

    try {
      return await this.strategy.selectGateway(params)
    } catch (error) {
      this.failureCount++
      this.lastFailureTime = Date.now()

      if (this.failureCount >= this.failureThreshold) {
        this.isOpen = true
      }

      throw error
    }
  }
}
```

### With Retry Logic

```javascript
class RetryStaticStrategy {
  constructor({ gateway, maxRetries = 3, retryDelayMs = 1000 }) {
    this.strategy = new StaticRoutingStrategy({ gateway })
    this.maxRetries = maxRetries
    this.retryDelayMs = retryDelayMs
  }

  async selectGateway(params) {
    let lastError

    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        return await this.strategy.selectGateway(params)
      } catch (error) {
        lastError = error

        if (attempt < this.maxRetries) {
          await new Promise((resolve) =>
            setTimeout(resolve, this.retryDelayMs * (attempt + 1)),
          )
        }
      }
    }

    throw lastError
  }
}
```

## Best Practices

1. **Use for specific scenarios**: Development, testing, dedicated gateways
2. **Monitor gateway health**: Ensure your static gateway is reliable
3. **Consider fallbacks**: Use as part of a fallback strategy
4. **Environment configuration**: Use different gateways per environment
5. **Load balancing**: Consider using a load balancer URL for redundancy
6. **Documentation**: Clearly document why static routing is used

## Common Patterns

### Development vs Production

```javascript
const createStrategy = () => {
  if (process.env.NODE_ENV === 'development') {
    return new StaticRoutingStrategy({
      gateway: 'http://localhost:1984',
    })
  }

  return new FastestPingRoutingStrategy({
    timeoutMs: 2000,
  })
}
```

### Gateway Override

```javascript
const createStrategy = (overrideGateway) => {
  if (overrideGateway) {
    return new StaticRoutingStrategy({
      gateway: overrideGateway,
    })
  }

  return new PreferredWithFallbackRoutingStrategy({
    preferredGateway: new URL('https://arweave.net'),
    fallbackStrategy: new FastestPingRoutingStrategy(),
  })
}

// Usage
const strategy = createStrategy(process.env.FORCE_GATEWAY)
```

## Related Strategies

- **[FastestPingRoutingStrategy](/wayfinder/routing-strategies/fastest-ping)**: Dynamic gateway selection
- **[PreferredWithFallbackRoutingStrategy](/wayfinder/routing-strategies/preferred-with-fallback)**: Can use static as fallback
- **[RandomRoutingStrategy](/wayfinder/routing-strategies/random)**: Random selection from multiple gateways
- **[SimpleCacheRoutingStrategy](/wayfinder/routing-strategies/simple-cache)**: Can wrap static strategy for consistency
