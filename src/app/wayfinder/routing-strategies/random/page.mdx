# RandomRoutingStrategy

## Overview

The `RandomRoutingStrategy` selects gateways randomly from the available pool. This strategy provides simple load distribution without maintaining state or performing complex calculations, making it ideal for scenarios where unpredictability is desired or where simplicity is paramount.

## How It Works

1. **Receive Gateway List**: Accept the list of available gateways
2. **Generate Random Index**: Create a random number within the gateway list range
3. **Select Gateway**: Choose the gateway at the random index
4. **Apply Filters**: Optionally filter out unhealthy or blocked gateways
5. **Return Selection**: Return the randomly selected gateway

## Configuration

### Basic Usage

```javascript
import { RandomRoutingStrategy } from '@ar.io/wayfinder-core'

const strategy = new RandomRoutingStrategy()
```

### Advanced Configuration

```javascript
const strategy = new RandomRoutingStrategy({
  seed: 12345, // Optional seed for reproducible randomness
  healthCheckEnabled: true,
  healthCheckInterval: 30000,
  healthCheckPath: '/ar-io/health',
  healthCheckTimeout: 5000,
  skipUnhealthyGateways: true,
  weightedSelection: false,
  weights: new Map([
    ['https://gateway-1.com', 2],
    ['https://gateway-2.com', 1],
    ['https://gateway-3.com', 3],
  ]),
  blacklistEnabled: true,
  blacklist: new Set(['https://blocked-gateway.com']),
  retryAttempts: 3,
  retryDelayMs: 1000,
})
```

## Parameters

| Parameter               | Type                  | Default         | Description                                                 |
| ----------------------- | --------------------- | --------------- | ----------------------------------------------------------- |
| `seed`                  | `number`              | `undefined`     | Seed for random number generator (for reproducible results) |
| `healthCheckEnabled`    | `boolean`             | `false`         | Whether to perform health checks                            |
| `healthCheckInterval`   | `number`              | `30000`         | Health check interval in milliseconds                       |
| `healthCheckPath`       | `string`              | `'/ar-io/info'` | Path for health checks                                      |
| `healthCheckTimeout`    | `number`              | `5000`          | Health check timeout                                        |
| `skipUnhealthyGateways` | `boolean`             | `true`          | Skip gateways that fail health checks                       |
| `weightedSelection`     | `boolean`             | `false`         | Use weighted random selection                               |
| `weights`               | `Map<string, number>` | `new Map()`     | Gateway weights for weighted selection                      |
| `blacklistEnabled`      | `boolean`             | `false`         | Enable gateway blacklisting                                 |
| `blacklist`             | `Set<string>`         | `new Set()`     | Set of blacklisted gateway URLs                             |
| `retryAttempts`         | `number`              | `3`             | Number of retry attempts if selection fails                 |
| `retryDelayMs`          | `number`              | `1000`          | Delay between retry attempts                                |

## Integration Examples

### With Wayfinder

```javascript
import { Wayfinder, RandomRoutingStrategy } from '@ar.io/wayfinder-core'

const wayfinder = new Wayfinder({
  routingSettings: {
    strategy: new RandomRoutingStrategy({
      healthCheckEnabled: true,
      skipUnhealthyGateways: true,
    }),
    events: {
      onRoutingStarted: (event) => {
        console.log('🎲 Random routing for:', event.originalUrl)
      },
      onGatewaySelected: (event) => {
        console.log('✅ Randomly selected gateway:', {
          gateway: event.selectedGateway,
          totalGateways: event.totalGateways,
          selectionProbability: 1 / event.totalGateways,
        })
      },
      onGatewaySkipped: (event) => {
        console.log('⚠️ Skipped gateway:', event.gateway, event.reason)
      },
    },
  },
})
```

### With Weighted Random Selection

```javascript
const weightedStrategy = new RandomRoutingStrategy({
  weightedSelection: true,
  weights: new Map([
    ['https://high-capacity-gateway.com', 5], // 5x more likely
    ['https://medium-capacity-gateway.com', 3], // 3x more likely
    ['https://low-capacity-gateway.com', 1], // 1x likely (baseline)
  ]),
})

// Usage with Wayfinder
const wayfinder = new Wayfinder({
  routingSettings: {
    strategy: weightedStrategy,
  },
})
```

### With Blacklisting

```javascript
const blacklistStrategy = new RandomRoutingStrategy({
  blacklistEnabled: true,
  blacklist: new Set([
    'https://unreliable-gateway.com',
    'https://slow-gateway.com',
  ]),
  healthCheckEnabled: true,
  skipUnhealthyGateways: true,
})
```

## Advanced Features

### Seeded Random Selection

```javascript
class SeededRandomStrategy extends RandomRoutingStrategy {
  constructor(options) {
    super(options)
    this.seed = options.seed || Date.now()
    this.rng = this.createSeededRNG(this.seed)
  }

  createSeededRNG(seed) {
    // Simple seeded random number generator (Mulberry32)
    return function () {
      let t = (seed += 0x6d2b79f5)
      t = Math.imul(t ^ (t >>> 15), t | 1)
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61)
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296
    }
  }

  async selectGateway({ gateways }) {
    const availableGateways = await this.filterGateways(gateways)

    if (availableGateways.length === 0) {
      throw new Error('No available gateways for random selection')
    }

    const randomIndex = Math.floor(this.rng() * availableGateways.length)
    return availableGateways[randomIndex]
  }
}

// Usage for reproducible testing
const testStrategy = new SeededRandomStrategy({
  seed: 42, // Same seed = same sequence
  healthCheckEnabled: true,
})
```

### Geographic-Aware Random Selection

```javascript
class GeographicRandomStrategy extends RandomRoutingStrategy {
  constructor(options) {
    super(options)
    this.userLocation = options.userLocation
    this.gatewayLocations = options.gatewayLocations || new Map()
    this.preferNearbyGateways = options.preferNearbyGateways || false
    this.maxDistance = options.maxDistance || 5000 // 5000km
  }

  async selectGateway({ gateways }) {
    let candidateGateways = gateways

    if (this.preferNearbyGateways && this.userLocation) {
      // Filter for nearby gateways first
      const nearbyGateways = this.filterByDistance(gateways, this.maxDistance)

      if (nearbyGateways.length > 0) {
        candidateGateways = nearbyGateways
        console.log(
          `🌍 Using ${nearbyGateways.length} nearby gateways for random selection`,
        )
      }
    }

    return super.selectGateway({ gateways: candidateGateways })
  }

  filterByDistance(gateways, maxDistance) {
    if (!this.userLocation) return gateways

    return gateways.filter((gateway) => {
      const gatewayLocation = this.gatewayLocations.get(gateway)
      if (!gatewayLocation) return true // Include if location unknown

      const distance = this.calculateDistance(
        this.userLocation,
        gatewayLocation,
      )
      return distance <= maxDistance
    })
  }

  calculateDistance(loc1, loc2) {
    // Haversine formula
    const R = 6371 // Earth's radius in kilometers
    const dLat = this.toRadians(loc2.lat - loc1.lat)
    const dLon = this.toRadians(loc2.lon - loc1.lon)

    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.toRadians(loc1.lat)) *
        Math.cos(this.toRadians(loc2.lat)) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2)

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
    return R * c
  }

  toRadians(degrees) {
    return degrees * (Math.PI / 180)
  }
}
```

### Adaptive Random Selection

```javascript
class AdaptiveRandomStrategy extends RandomRoutingStrategy {
  constructor(options) {
    super(options)
    this.performanceHistory = new Map()
    this.adaptiveWeights = options.adaptiveWeights || false
    this.learningRate = options.learningRate || 0.1
    this.minWeight = options.minWeight || 0.1
    this.maxWeight = options.maxWeight || 5.0
  }

  async selectGateway({ gateways }) {
    if (this.adaptiveWeights) {
      this.updateWeightsBasedOnPerformance()
    }

    return super.selectGateway({ gateways })
  }

  updateWeightsBasedOnPerformance() {
    for (const [gateway, history] of this.performanceHistory.entries()) {
      const currentWeight = this.weights.get(gateway) || 1.0
      const avgResponseTime = this.calculateAverageResponseTime(history)
      const successRate = this.calculateSuccessRate(history)

      // Better performance = higher weight
      const performanceScore = successRate / Math.max(avgResponseTime, 100)
      const targetWeight = Math.max(
        this.minWeight,
        Math.min(this.maxWeight, performanceScore),
      )

      // Gradually adjust weight using learning rate
      const newWeight =
        currentWeight + this.learningRate * (targetWeight - currentWeight)
      this.weights.set(gateway, newWeight)
    }
  }

  recordPerformance(gateway, responseTime, success) {
    if (!this.performanceHistory.has(gateway)) {
      this.performanceHistory.set(gateway, [])
    }

    const history = this.performanceHistory.get(gateway)
    history.push({ responseTime, success, timestamp: Date.now() })

    // Keep only recent history (last 100 requests)
    if (history.length > 100) {
      history.shift()
    }
  }

  calculateAverageResponseTime(history) {
    const responseTimes = history.map((h) => h.responseTime).filter(Boolean)
    return responseTimes.length > 0
      ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
      : 1000 // Default 1s if no data
  }

  calculateSuccessRate(history) {
    if (history.length === 0) return 1.0
    const successCount = history.filter((h) => h.success).length
    return successCount / history.length
  }
}
```

## Performance Optimization

### Efficient Random Selection

```javascript
class OptimizedRandomStrategy extends RandomRoutingStrategy {
  constructor(options) {
    super(options)
    this.gatewayPool = []
    this.poolUpdateInterval = options.poolUpdateInterval || 60000
    this.lastPoolUpdate = 0
  }

  async selectGateway({ gateways }) {
    // Update gateway pool if needed
    if (Date.now() - this.lastPoolUpdate > this.poolUpdateInterval) {
      await this.updateGatewayPool(gateways)
    }

    // Use pre-filtered pool for faster selection
    if (this.gatewayPool.length === 0) {
      throw new Error('No gateways available in pool')
    }

    const randomIndex = Math.floor(Math.random() * this.gatewayPool.length)
    return this.gatewayPool[randomIndex]
  }

  async updateGatewayPool(gateways) {
    console.log('🔄 Updating gateway pool...')

    // Filter out unhealthy and blacklisted gateways
    const healthyGateways = []

    for (const gateway of gateways) {
      if (this.isGatewayAllowed(gateway)) {
        if (
          !this.healthCheckEnabled ||
          (await this.isGatewayHealthy(gateway))
        ) {
          healthyGateways.push(gateway)
        }
      }
    }

    this.gatewayPool = healthyGateways
    this.lastPoolUpdate = Date.now()

    console.log(
      `✅ Gateway pool updated: ${this.gatewayPool.length} healthy gateways`,
    )
  }

  isGatewayAllowed(gateway) {
    return !this.blacklistEnabled || !this.blacklist.has(gateway)
  }
}
```

### Weighted Random with Alias Method

```javascript
class AliasMethodRandomStrategy extends RandomRoutingStrategy {
  constructor(options) {
    super(options)
    this.aliasTable = null
    this.probabilityTable = null
    this.weightsChanged = true
  }

  async selectGateway({ gateways }) {
    if (this.weightedSelection && this.weightsChanged) {
      this.buildAliasTable(gateways)
      this.weightsChanged = false
    }

    if (this.weightedSelection && this.aliasTable) {
      return this.selectUsingAliasMethod(gateways)
    }

    return super.selectGateway({ gateways })
  }

  buildAliasTable(gateways) {
    const n = gateways.length
    const weights = gateways.map((g) => this.weights.get(g) || 1)
    const totalWeight = weights.reduce((a, b) => a + b, 0)

    // Normalize weights
    const probabilities = weights.map((w) => (w * n) / totalWeight)

    const alias = new Array(n)
    const prob = new Array(n)
    const small = []
    const large = []

    // Classify probabilities
    for (let i = 0; i < n; i++) {
      if (probabilities[i] < 1.0) {
        small.push(i)
      } else {
        large.push(i)
      }
    }

    // Build alias table
    while (small.length > 0 && large.length > 0) {
      const l = small.pop()
      const g = large.pop()

      prob[l] = probabilities[l]
      alias[l] = g

      probabilities[g] = probabilities[g] + probabilities[l] - 1.0

      if (probabilities[g] < 1.0) {
        small.push(g)
      } else {
        large.push(g)
      }
    }

    while (large.length > 0) {
      prob[large.pop()] = 1.0
    }

    while (small.length > 0) {
      prob[small.pop()] = 1.0
    }

    this.probabilityTable = prob
    this.aliasTable = alias
  }

  selectUsingAliasMethod(gateways) {
    const n = gateways.length
    const i = Math.floor(Math.random() * n)

    if (Math.random() < this.probabilityTable[i]) {
      return gateways[i]
    } else {
      return gateways[this.aliasTable[i]]
    }
  }
}
```

## Use Cases

### Simple Load Distribution

```javascript
const simpleStrategy = new RandomRoutingStrategy()

const wayfinder = new Wayfinder({
  routingSettings: {
    strategy: simpleStrategy,
  },
})
```

### Testing and Development

```javascript
// Reproducible random selection for testing
const testStrategy = new RandomRoutingStrategy({
  seed: 42, // Fixed seed for consistent results
  healthCheckEnabled: false, // Disable for faster testing
})

// Chaos testing - random selection with blacklisting
const chaosStrategy = new RandomRoutingStrategy({
  blacklistEnabled: true,
  blacklist: new Set(), // Start empty, add problematic gateways
  retryAttempts: 5,
  retryDelayMs: 500,
})
```

### Weighted Load Balancing

```javascript
const weightedStrategy = new RandomRoutingStrategy({
  weightedSelection: true,
  weights: new Map([
    ['https://tier1-gateway.com', 4], // Premium tier
    ['https://tier2-gateway.com', 2], // Standard tier
    ['https://tier3-gateway.com', 1], // Basic tier
  ]),
  healthCheckEnabled: true,
  skipUnhealthyGateways: true,
})
```

### Geographic Distribution

```javascript
const geoStrategy = new GeographicRandomStrategy({
  userLocation: { lat: 40.7128, lon: -74.006 }, // New York
  gatewayLocations: new Map([
    ['https://us-east.gateway.com', { lat: 40.7128, lon: -74.006 }],
    ['https://us-west.gateway.com', { lat: 37.7749, lon: -122.4194 }],
    ['https://eu.gateway.com', { lat: 51.5074, lon: -0.1278 }],
  ]),
  preferNearbyGateways: true,
  maxDistance: 2000, // 2000km radius
})
```

### High-Availability Setup

```javascript
const haStrategy = new RandomRoutingStrategy({
  healthCheckEnabled: true,
  healthCheckInterval: 15000,
  skipUnhealthyGateways: true,
  retryAttempts: 3,
  retryDelayMs: 1000,
  blacklistEnabled: true,
  // Blacklist gets populated dynamically based on failures
  onGatewayFailure: (gateway, error) => {
    console.warn('Gateway failed, adding to blacklist:', gateway)
    haStrategy.blacklist.add(gateway)

    // Remove from blacklist after 5 minutes
    setTimeout(
      () => {
        haStrategy.blacklist.delete(gateway)
        console.log('Removed gateway from blacklist:', gateway)
      },
      5 * 60 * 1000,
    )
  },
})
```

## Error Handling

### Common Error Types

```javascript
try {
  const selectedGateway = await strategy.selectGateway({ gateways })
  console.log('Selected gateway:', selectedGateway)
} catch (error) {
  switch (error.constructor.name) {
    case 'NoAvailableGatewaysError':
      console.error('No gateways available for random selection')
      // Check gateway list and health status
      break

    case 'AllGatewaysBlacklistedError':
      console.error('All gateways are blacklisted')
      // Clear blacklist or add emergency gateways
      break

    case 'RandomSelectionError':
      console.error('Error in random selection logic')
      // Reset random number generator or weights
      break

    case 'WeightConfigurationError':
      console.error('Invalid weight configuration')
      // Check weight values and gateway mapping
      break

    default:
      console.error('Unknown routing error:', error.message)
  }
}
```

### Graceful Degradation

```javascript
const robustStrategy = new RandomRoutingStrategy({
  healthCheckEnabled: true,
  skipUnhealthyGateways: true,
  retryAttempts: 5,
  onSelectionFailed: (attempt, error) => {
    console.warn(`Random selection attempt ${attempt} failed:`, error.message)

    if (attempt === 3) {
      // Clear blacklist on 3rd attempt
      console.log('Clearing blacklist to expand gateway pool')
      robustStrategy.blacklist.clear()
    }

    return true // Continue retrying
  },
  onAllAttemptsFailed: (gateways, error) => {
    console.error(
      'All random selection attempts failed, using first available gateway',
    )
    // Return first gateway as emergency fallback
    return gateways.length > 0 ? gateways[0] : null
  },
})
```

## Testing

### Unit Testing

```javascript
import { RandomRoutingStrategy } from '@ar.io/wayfinder-core'

describe('RandomRoutingStrategy', () => {
  let strategy

  beforeEach(() => {
    strategy = new RandomRoutingStrategy()
  })

  test('should select random gateway from list', async () => {
    const gateways = [
      'https://gateway-1.com',
      'https://gateway-2.com',
      'https://gateway-3.com',
    ]

    const selected = await strategy.selectGateway({ gateways })
    expect(gateways).toContain(selected)
  })

  test('should respect weights in weighted selection', async () => {
    const weightedStrategy = new RandomRoutingStrategy({
      weightedSelection: true,
      weights: new Map([
        ['https://heavy-gateway.com', 10],
        ['https://light-gateway.com', 1],
      ]),
    })

    const gateways = ['https://heavy-gateway.com', 'https://light-gateway.com']

    // Run multiple selections to test weight distribution
    const selections = []
    for (let i = 0; i < 100; i++) {
      const selected = await weightedStrategy.selectGateway({ gateways })
      selections.push(selected)
    }

    const heavyCount = selections.filter(
      (s) => s === 'https://heavy-gateway.com',
    ).length
    const lightCount = selections.filter(
      (s) => s === 'https://light-gateway.com',
    ).length

    // Heavy gateway should be selected more often (approximately 10:1 ratio)
    expect(heavyCount).toBeGreaterThan(lightCount * 5)
  })

  test('should skip blacklisted gateways', async () => {
    const blacklistStrategy = new RandomRoutingStrategy({
      blacklistEnabled: true,
      blacklist: new Set(['https://blacklisted-gateway.com']),
    })

    const gateways = [
      'https://blacklisted-gateway.com',
      'https://allowed-gateway.com',
    ]

    const selected = await blacklistStrategy.selectGateway({ gateways })
    expect(selected).toBe('https://allowed-gateway.com')
  })

  test('should handle empty gateway list', async () => {
    await expect(strategy.selectGateway({ gateways: [] })).rejects.toThrow(
      'No gateways available',
    )
  })

  test('should produce consistent results with seed', async () => {
    const seededStrategy1 = new RandomRoutingStrategy({ seed: 12345 })
    const seededStrategy2 = new RandomRoutingStrategy({ seed: 12345 })

    const gateways = [
      'https://gateway-1.com',
      'https://gateway-2.com',
      'https://gateway-3.com',
    ]

    const results1 = []
    const results2 = []

    for (let i = 0; i < 10; i++) {
      results1.push(await seededStrategy1.selectGateway({ gateways }))
      results2.push(await seededStrategy2.selectGateway({ gateways }))
    }

    expect(results1).toEqual(results2)
  })
})
```

### Integration Testing

```javascript
describe('RandomRoutingStrategy Integration', () => {
  test('should work with real gateways', async () => {
    const strategy = new RandomRoutingStrategy({
      healthCheckEnabled: true,
      healthCheckTimeout: 3000,
    })

    const gateways = ['https://arweave.net', 'https://ar-io.net']

    const selected = await strategy.selectGateway({ gateways })
    expect(gateways).toContain(selected)
  })

  test('should handle gateway failures gracefully', async () => {
    const strategy = new RandomRoutingStrategy({
      healthCheckEnabled: true,
      skipUnhealthyGateways: true,
      retryAttempts: 3,
    })

    const gateways = [
      'https://nonexistent-gateway.invalid',
      'https://arweave.net',
    ]

    const selected = await strategy.selectGateway({ gateways })
    expect(selected).toBe('https://arweave.net')
  })
})
```

## Best Practices

1. **Use for Simple Scenarios**: Random selection works best when all gateways are roughly equivalent
2. **Enable Health Checks**: Filter out unhealthy gateways to improve reliability
3. **Consider Weighted Selection**: Use weights when gateways have different capacities
4. **Implement Blacklisting**: Temporarily exclude problematic gateways
5. **Monitor Distribution**: Track selection patterns to ensure even distribution
6. **Use Seeds for Testing**: Enable reproducible behavior in test environments
7. **Handle Edge Cases**: Plan for scenarios with no available gateways
8. **Combine with Other Strategies**: Use as a fallback for more complex strategies

## Comparison with Other Strategies

| Aspect                | Random              | Fastest Ping   | Preferred + Fallback     | Round Robin    |
| --------------------- | ------------------- | -------------- | ------------------------ | -------------- |
| **Performance**       | ⭐⭐                | ⭐⭐⭐⭐⭐     | ⭐⭐⭐⭐                 | ⭐⭐           |
| **Reliability**       | ⭐⭐⭐              | ⭐⭐⭐⭐       | ⭐⭐⭐                   | ⭐⭐⭐         |
| **Load Distribution** | ⭐⭐⭐⭐            | ⭐⭐           | ⭐                       | ⭐⭐⭐⭐⭐     |
| **Predictability**    | ⭐                  | ⭐⭐⭐         | ⭐⭐⭐⭐⭐               | ⭐⭐⭐⭐       |
| **Simplicity**        | ⭐⭐⭐⭐⭐          | ⭐⭐⭐         | ⭐⭐⭐⭐                 | ⭐⭐           |
| **Use Case**          | Simple distribution | Real-time apps | Dedicated infrastructure | Load balancing |

The `RandomRoutingStrategy` is ideal for applications that need simple, unpredictable gateway selection without complex logic or state management.
