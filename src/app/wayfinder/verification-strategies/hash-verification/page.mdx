import { Table } from '@/components/Table'

# HashVerificationStrategy

## Overview

The `HashVerificationStrategy` verifies data integrity by comparing SHA-256 hashes of fetched data against trusted sources. This strategy provides fast, cryptographically secure verification by ensuring the data you receive matches the hash from a trusted gateway.

## How It Works

1. **Fetch Data**: Retrieve content from the selected gateway
2. **Compute Hash**: Calculate the SHA-256 hash of the received data
3. **Request Trusted Hash**: Get the hash from a trusted gateway
4. **Compare**: Verify that both hashes match exactly
5. **Result**: Pass or fail based on hash comparison

## Configuration

### Basic Usage

```javascript
import { HashVerificationStrategy } from '@ar.io/wayfinder-core'

const strategy = new HashVerificationStrategy({
  trustedGateways: ['https://arweave.net'],
})
```

### Advanced Configuration

```javascript
const strategy = new HashVerificationStrategy({
  trustedGateways: [
    'https://arweave.net',
    'https://ar-io.net',
    'https://permagate.io',
  ],
  timeoutMs: 5000,
  retryAttempts: 3,
  retryDelayMs: 1000,
  hashAlgorithm: 'sha256', // Default algorithm
})
```

## Parameters

<Table>
  <Table.Head>
    <Table.Row>
      <Table.Header>Parameter</Table.Header>
      <Table.Header>Type</Table.Header>
      <Table.Header>Default</Table.Header>
      <Table.Header>Description</Table.Header>
    </Table.Row>
  </Table.Head>
  <Table.Body>
    <Table.Row>
      <Table.Cell>`trustedGateways`</Table.Cell>
      <Table.Cell>`string[]`</Table.Cell>
      <Table.Cell>`['https://arweave.net']`</Table.Cell>
      <Table.Cell>List of trusted gateways for hash comparison</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`timeoutMs`</Table.Cell>
      <Table.Cell>`number`</Table.Cell>
      <Table.Cell>`10000`</Table.Cell>
      <Table.Cell>Timeout for hash requests in milliseconds</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`retryAttempts`</Table.Cell>
      <Table.Cell>`number`</Table.Cell>
      <Table.Cell>`2`</Table.Cell>
      <Table.Cell>Number of retry attempts for failed hash requests</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`retryDelayMs`</Table.Cell>
      <Table.Cell>`number`</Table.Cell>
      <Table.Cell>`1000`</Table.Cell>
      <Table.Cell>Delay between retry attempts</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`hashAlgorithm`</Table.Cell>
      <Table.Cell>`string`</Table.Cell>
      <Table.Cell>`'sha256'`</Table.Cell>
      <Table.Cell>Hash algorithm to use</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

## Integration Examples

### With Wayfinder

```javascript
import { Wayfinder, HashVerificationStrategy } from '@ar.io/wayfinder-core'

const wayfinder = new Wayfinder({
  verificationSettings: {
    enabled: true,
    strategy: new HashVerificationStrategy({
      trustedGateways: ['https://arweave.net'],
    }),
    strict: true,
  },
})

// Verification happens automatically
const response = await wayfinder.request('ar://transaction-id')
const data = await response.text()
```

### With Event Monitoring

```javascript
const wayfinder = new Wayfinder({
  verificationSettings: {
    enabled: true,
    strategy: new HashVerificationStrategy({
      trustedGateways: ['https://arweave.net'],
    }),
    events: {
      onVerificationSucceeded: (event) => {
        console.log('✅ Hash verification passed:', {
          txId: event.txId,
          gateway: event.gateway,
          hashMatched: true,
        })
      },
      onVerificationFailed: (error) => {
        console.error('❌ Hash verification failed:', {
          error: error.message,
          type: error.constructor.name,
        })
      },
    },
  },
})
```

### Standalone Usage

```javascript
const strategy = new HashVerificationStrategy({
  trustedGateways: ['https://arweave.net'],
})

// Manual verification
try {
  await strategy.verifyData({
    data: dataBuffer,
    txId: 'transaction-id',
    originalUrl: 'ar://transaction-id',
  })
  console.log('Verification passed!')
} catch (error) {
  console.error('Verification failed:', error.message)
}
```

## Error Handling

### Common Error Types

```javascript
try {
  const response = await wayfinder.request('ar://transaction-id')
  const data = await response.text()
} catch (error) {
  switch (error.constructor.name) {
    case 'HashMismatchError':
      console.error('Data hash does not match trusted source')
      // Data may be corrupted or tampered with
      break

    case 'TrustedGatewayError':
      console.error('Failed to fetch hash from trusted gateways')
      // Network issues or trusted gateway unavailable
      break

    case 'VerificationTimeoutError':
      console.error('Hash verification timed out')
      // Increase timeout or check network connectivity
      break

    case 'InvalidTransactionError':
      console.error('Invalid transaction ID format')
      // Check that the transaction ID is valid
      break

    default:
      console.error('Unknown verification error:', error.message)
  }
}
```

### Graceful Error Handling

```javascript
const strategy = new HashVerificationStrategy({
  trustedGateways: ['https://arweave.net'],
  onError: (error, context) => {
    // Log error but don't throw
    console.warn('Hash verification failed:', {
      error: error.message,
      txId: context.txId,
      gateway: context.gateway,
    })

    // Optionally report to monitoring service
    reportVerificationFailure(error, context)
  },
})
```

## Performance Considerations

### Optimization Strategies

#### 1. Cache Hash Results

```javascript
class CachedHashVerificationStrategy extends HashVerificationStrategy {
  constructor(options) {
    super(options)
    this.hashCache = new Map()
  }

  async verifyData(params) {
    const cacheKey = params.txId

    if (this.hashCache.has(cacheKey)) {
      const cachedHash = this.hashCache.get(cacheKey)
      const dataHash = await this.computeHash(params.data)

      if (dataHash === cachedHash) {
        return // Verification passed
      } else {
        throw new Error('Hash mismatch with cached value')
      }
    }

    // Perform normal verification and cache result
    await super.verifyData(params)
    const dataHash = await this.computeHash(params.data)
    this.hashCache.set(cacheKey, dataHash)
  }
}
```

#### 2. Parallel Hash Requests

```javascript
const strategy = new HashVerificationStrategy({
  trustedGateways: [
    'https://arweave.net',
    'https://ar-io.net',
    'https://permagate.io',
  ],
  // Use fastest responding gateway
  useFirstResponse: true,
})
```

#### 3. Streaming Verification

```javascript
const strategy = new HashVerificationStrategy({
  trustedGateways: ['https://arweave.net'],
  streamingVerification: true, // Verify data as it streams
  chunkSize: 64 * 1024, // 64KB chunks
})
```

### Performance Metrics

```javascript
class InstrumentedHashVerificationStrategy extends HashVerificationStrategy {
  constructor(options) {
    super(options)
    this.metrics = {
      verificationCount: 0,
      successCount: 0,
      failureCount: 0,
      averageTime: 0,
      totalTime: 0,
    }
  }

  async verifyData(params) {
    const startTime = Date.now()
    this.metrics.verificationCount++

    try {
      await super.verifyData(params)
      this.metrics.successCount++
    } catch (error) {
      this.metrics.failureCount++
      throw error
    } finally {
      const duration = Date.now() - startTime
      this.metrics.totalTime += duration
      this.metrics.averageTime =
        this.metrics.totalTime / this.metrics.verificationCount
    }
  }

  getMetrics() {
    return {
      ...this.metrics,
      successRate:
        (this.metrics.successCount / this.metrics.verificationCount) * 100,
    }
  }
}
```

## Security Considerations

### Trusted Gateway Selection

Choose trusted gateways carefully:

```javascript
// Good: Well-known, reputable gateways
const trustedGateways = [
  'https://arweave.net', // Official Arweave gateway
  'https://ar-io.net', // AR.IO official gateway
  'https://permagate.io', // Community trusted gateway
]

// Avoid: Unknown or untrusted gateways
const untrustedGateways = [
  'https://random-gateway.com',
  'https://suspicious-domain.net',
]
```

### Hash Algorithm Security

```javascript
// Secure: Use strong hash algorithms
const strategy = new HashVerificationStrategy({
  trustedGateways: ['https://arweave.net'],
  hashAlgorithm: 'sha256', // Cryptographically secure
})

// Less secure: Weaker algorithms (not recommended)
const weakStrategy = new HashVerificationStrategy({
  hashAlgorithm: 'md5', // Vulnerable to collision attacks
})
```

### Network Security

```javascript
const strategy = new HashVerificationStrategy({
  trustedGateways: ['https://arweave.net'],
  // Always use HTTPS for trusted gateway requests
  enforceHttps: true,
  // Verify SSL certificates
  verifySsl: true,
  // Set reasonable timeouts to prevent hanging
  timeoutMs: 10000,
})
```

## Use Cases

### Development Environment

Fast verification for development:

```javascript
const devStrategy = new HashVerificationStrategy({
  trustedGateways: ['https://arweave.net'],
  timeoutMs: 3000, // Shorter timeout for dev
  retryAttempts: 1, // Fewer retries for faster iteration
})
```

### Production Environment

Robust verification for production:

```javascript
const prodStrategy = new HashVerificationStrategy({
  trustedGateways: ['https://arweave.net', 'https://ar-io.net'],
  timeoutMs: 10000,
  retryAttempts: 3,
  retryDelayMs: 2000,
})
```

### High-Performance Environment

Optimized for throughput:

```javascript
const highPerfStrategy = new HashVerificationStrategy({
  trustedGateways: ['https://arweave.net'],
  useFirstResponse: true, // Use fastest gateway
  streamingVerification: true, // Stream verification
  cacheResults: true, // Cache hash results
})
```

### High-Security Environment

Maximum security configuration:

```javascript
const secureStrategy = new HashVerificationStrategy({
  trustedGateways: [
    'https://arweave.net',
    'https://ar-io.net',
    'https://permagate.io',
  ],
  requireConsensus: true, // Require multiple gateways to agree
  consensusThreshold: 2, // At least 2 gateways must match
  enforceHttps: true,
  verifySsl: true,
})
```

## Testing

### Unit Testing

```javascript
import { HashVerificationStrategy } from '@ar.io/wayfinder-core'

describe('HashVerificationStrategy', () => {
  let strategy

  beforeEach(() => {
    strategy = new HashVerificationStrategy({
      trustedGateways: ['https://test-gateway.com'],
    })
  })

  test('should verify matching hashes', async () => {
    const testData = new TextEncoder().encode('test data')

    // Mock the trusted gateway response
    jest.spyOn(strategy, 'fetchTrustedHash').mockResolvedValue('expected-hash')
    jest.spyOn(strategy, 'computeHash').mockResolvedValue('expected-hash')

    await expect(
      strategy.verifyData({
        data: testData,
        txId: 'test-tx-id',
        originalUrl: 'ar://test-tx-id',
      }),
    ).resolves.not.toThrow()
  })

  test('should fail on hash mismatch', async () => {
    const testData = new TextEncoder().encode('test data')

    jest.spyOn(strategy, 'fetchTrustedHash').mockResolvedValue('expected-hash')
    jest.spyOn(strategy, 'computeHash').mockResolvedValue('different-hash')

    await expect(
      strategy.verifyData({
        data: testData,
        txId: 'test-tx-id',
        originalUrl: 'ar://test-tx-id',
      }),
    ).rejects.toThrow('Hash mismatch')
  })
})
```

### Integration Testing

```javascript
describe('HashVerificationStrategy Integration', () => {
  test('should verify real transaction data', async () => {
    const strategy = new HashVerificationStrategy({
      trustedGateways: ['https://arweave.net'],
    })

    // Use a known transaction for testing
    const testTxId = 'known-test-transaction-id'
    const response = await fetch(`https://arweave.net/${testTxId}`)
    const data = await response.arrayBuffer()

    await expect(
      strategy.verifyData({
        data,
        txId: testTxId,
        originalUrl: `ar://${testTxId}`,
      }),
    ).resolves.not.toThrow()
  })
})
```

## Best Practices

1. **Use Multiple Trusted Gateways**: Increases reliability and security
2. **Set Appropriate Timeouts**: Balance between reliability and performance
3. **Implement Caching**: Cache hash results for frequently accessed content
4. **Monitor Performance**: Track verification success rates and timing
5. **Handle Errors Gracefully**: Don't let verification failures break user experience
6. **Choose Strong Hash Algorithms**: Use SHA-256 or stronger algorithms
7. **Validate Trusted Gateways**: Regularly verify that trusted gateways are reliable
8. **Use HTTPS**: Always use secure connections for trusted gateway requests

## Comparison with Other Strategies

<Table>
  <Table.Head>
    <Table.Row>
      <Table.Header>Aspect</Table.Header>
      <Table.Header>Hash Verification</Table.Header>
      <Table.Header>Signature Verification</Table.Header>
      <Table.Header>Data Root Verification</Table.Header>
    </Table.Row>
  </Table.Head>
  <Table.Body>
    <Table.Row>
      <Table.Cell>**Security**</Table.Cell>
      <Table.Cell>High</Table.Cell>
      <Table.Cell>Very High</Table.Cell>
      <Table.Cell>Highest</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>**Performance**</Table.Cell>
      <Table.Cell>⭐⭐⭐⭐⭐</Table.Cell>
      <Table.Cell>⭐⭐⭐⭐</Table.Cell>
      <Table.Cell>⭐⭐⭐</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>**Complexity**</Table.Cell>
      <Table.Cell>Low</Table.Cell>
      <Table.Cell>Medium</Table.Cell>
      <Table.Cell>High</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>**Network Overhead**</Table.Cell>
      <Table.Cell>Low</Table.Cell>
      <Table.Cell>Medium</Table.Cell>
      <Table.Cell>High</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>**Use Case**</Table.Cell>
      <Table.Cell>Fast integrity checks</Table.Cell>
      <Table.Cell>Authenticity validation</Table.Cell>
      <Table.Cell>Maximum security</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

The `HashVerificationStrategy` provides an excellent balance of security and performance, making it ideal for most applications that need fast, reliable data integrity verification.
