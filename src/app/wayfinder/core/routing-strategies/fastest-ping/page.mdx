import { Table } from '@/components/Table'

# FastestPingRoutingStrategy

## Overview

The `FastestPingRoutingStrategy` is a performance-optimized routing strategy that selects gateways based on the lowest response latency. It performs health checks and ping tests to identify the fastest available gateway for each request.

This strategy is ideal for applications that prioritize low latency and fast response times, such as real-time applications, interactive user experiences, and gaming platforms.

## Configuration

### Basic Configuration

```javascript
import { FastestPingRoutingStrategy } from '@ar.io/wayfinder-core'

const strategy = new FastestPingRoutingStrategy({
  timeoutMs: 2000,
  pingPath: '/ar-io/info',
  cacheResultsMs: 30000,
})
```

### Advanced Configuration

```javascript
const strategy = new FastestPingRoutingStrategy({
  timeoutMs: 2000, // Ping timeout in milliseconds
  pingPath: '/ar-io/info', // Health check endpoint
  cacheResultsMs: 30000, // Cache ping results for 30 seconds
  concurrentPings: 5, // Maximum concurrent ping operations
  retryAttempts: 2, // Number of retry attempts for failed pings
  retryDelayMs: 1000, // Delay between retry attempts
  minimumSuccessRate: 0.8, // Minimum success rate to consider gateway healthy
  weightLatency: true, // Use weighted selection based on latency
  healthCheckInterval: 60000, // Background health check interval
  circuitBreakerEnabled: true, // Enable circuit breaker for failed gateways
  circuitBreakerThreshold: 5, // Number of failures before opening circuit
  circuitBreakerTimeout: 30000, // Circuit breaker reset timeout
})
```

## Configuration Options

### Core Options

<Table>
  <Table.Head>
    <Table.Row>
      <Table.Header>Option</Table.Header>
      <Table.Header>Type</Table.Header>
      <Table.Header>Default</Table.Header>
      <Table.Header>Description</Table.Header>
    </Table.Row>
  </Table.Head>
  <Table.Body>
    <Table.Row>
      <Table.Cell>`timeoutMs`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>2000</Table.Cell>
      <Table.Cell>Maximum time to wait for ping response</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`pingPath`</Table.Cell>
      <Table.Cell>string</Table.Cell>
      <Table.Cell>'/ar-io/info'</Table.Cell>
      <Table.Cell>Endpoint path for health checks</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`cacheResultsMs`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>30000</Table.Cell>
      <Table.Cell>Duration to cache ping results</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`concurrentPings`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>3</Table.Cell>
      <Table.Cell>Maximum concurrent ping operations</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

### Advanced Options

<Table>
  <Table.Head>
    <Table.Row>
      <Table.Header>Option</Table.Header>
      <Table.Header>Type</Table.Header>
      <Table.Header>Default</Table.Header>
      <Table.Header>Description</Table.Header>
    </Table.Row>
  </Table.Head>
  <Table.Body>
    <Table.Row>
      <Table.Cell>`retryAttempts`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>1</Table.Cell>
      <Table.Cell>Number of retry attempts for failed pings</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`retryDelayMs`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>500</Table.Cell>
      <Table.Cell>Delay between retry attempts</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`minimumSuccessRate`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>0.7</Table.Cell>
      <Table.Cell>Minimum success rate for healthy gateways</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`weightLatency`</Table.Cell>
      <Table.Cell>boolean</Table.Cell>
      <Table.Cell>false</Table.Cell>
      <Table.Cell>Use weighted selection based on latency</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`healthCheckInterval`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>0</Table.Cell>
      <Table.Cell>Background health check interval (0 = disabled)</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

### Circuit Breaker Options

<Table>
  <Table.Head>
    <Table.Row>
      <Table.Header>Option</Table.Header>
      <Table.Header>Type</Table.Header>
      <Table.Header>Default</Table.Header>
      <Table.Header>Description</Table.Header>
    </Table.Row>
  </Table.Head>
  <Table.Body>
    <Table.Row>
      <Table.Cell>`circuitBreakerEnabled`</Table.Cell>
      <Table.Cell>boolean</Table.Cell>
      <Table.Cell>false</Table.Cell>
      <Table.Cell>Enable circuit breaker pattern</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`circuitBreakerThreshold`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>3</Table.Cell>
      <Table.Cell>Failures before opening circuit</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`circuitBreakerTimeout`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>30000</Table.Cell>
      <Table.Cell>Reset timeout for circuit breaker</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

## Usage Examples

### Basic Usage

```javascript
import { Wayfinder, FastestPingRoutingStrategy } from '@ar.io/wayfinder-core'

const wayfinder = new Wayfinder({
  routingStrategy: new FastestPingRoutingStrategy({
    timeoutMs: 1500,
    cacheResultsMs: 60000,
  }),
})

// Strategy will automatically ping gateways and select the fastest
const result = await wayfinder.request('/tx/transaction-id')
```

### High-Performance Configuration

```javascript
// Optimized for low-latency applications
const strategy = new FastestPingRoutingStrategy({
  timeoutMs: 1000, // Fast timeout for quick decisions
  pingPath: '/ar-io/healthcheck', // Custom health endpoint
  cacheResultsMs: 15000, // Short cache for frequent updates
  concurrentPings: 10, // High concurrency for fast pinging
  weightLatency: true, // Prefer faster gateways
  minimumSuccessRate: 0.9, // Strict success rate requirement
})

const wayfinder = new Wayfinder({
  routingStrategy: strategy,
})
```

### Production Configuration with Circuit Breaker

```javascript
// Production setup with reliability features
const strategy = new FastestPingRoutingStrategy({
  timeoutMs: 2500,
  pingPath: '/ar-io/info',
  cacheResultsMs: 45000,
  concurrentPings: 6,
  retryAttempts: 3,
  retryDelayMs: 1500,
  circuitBreakerEnabled: true,
  circuitBreakerThreshold: 5,
  circuitBreakerTimeout: 60000,
  healthCheckInterval: 120000, // Background health checks every 2 minutes
})

const wayfinder = new Wayfinder({
  routingStrategy: strategy,
})
```

## Advanced Features

### Weighted Latency Selection

```javascript
class WeightedLatencyStrategy extends FastestPingRoutingStrategy {
  constructor(options) {
    super({
      ...options,
      weightLatency: true,
    })
  }

  async selectGateway(context) {
    const pingResults = await this.pingAllGateways(context.gateways)

    if (pingResults.length === 0) {
      throw new Error('No healthy gateways available')
    }

    // Use weighted random selection based on inverse latency
    const weights = pingResults.map((result) => ({
      gateway: result.gateway,
      weight: 1000 / (result.latency + 100), // Inverse latency weighting
    }))

    return this.weightedRandomSelect(weights)
  }

  weightedRandomSelect(weights) {
    const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0)
    let random = Math.random() * totalWeight

    for (const weight of weights) {
      random -= weight.weight
      if (random <= 0) {
        return weight.gateway
      }
    }

    return weights[0].gateway // Fallback
  }
}
```

## Error Handling

### Common Error Types

```javascript
try {
  const gateway = await strategy.selectGateway(context)
  console.log('Selected fastest gateway:', gateway)
} catch (error) {
  switch (error.code) {
    case 'PING_TIMEOUT':
      console.error('All gateways timed out during ping')
      // Increase timeout or use fallback strategy
      break

    case 'NO_HEALTHY_GATEWAYS':
      console.error('No gateways passed health checks')
      // Relax health check criteria or use cached results
      break

    case 'PING_FAILED':
      console.error('Ping operation failed:', error.details)
      // Check network connectivity
      break

    case 'CIRCUIT_BREAKER_OPEN':
      console.error('Circuit breaker is open for all gateways')
      // Wait for circuit breaker reset or use emergency gateways
      break

    default:
      console.error('Unknown ping strategy error:', error.message)
  }
}
```

## Best Practices

1. **Set Appropriate Timeouts**: Balance responsiveness with reliability
2. **Use Caching**: Cache ping results to reduce overhead for repeated requests
3. **Implement Circuit Breakers**: Prevent repeatedly pinging failed gateways
4. **Monitor Performance**: Track ping metrics and success rates
5. **Handle Failures Gracefully**: Always have fallback strategies
6. **Limit Concurrency**: Control the number of simultaneous ping operations
7. **Consider Geography**: Factor in user location for latency optimization
8. **Test with Real Networks**: Validate against actual AR.IO gateways

## Performance Considerations

- **Initial Latency**: First request may be slower due to ping operations
- **Network Overhead**: Ping operations consume additional bandwidth
- **Concurrency Limits**: Too many concurrent pings can overwhelm the network
- **Cache Efficiency**: Proper caching reduces repeated ping overhead
- **Error Recovery**: Failed pings should not block other operations

## Related Documentation

- **[Routing Strategies Overview](/wayfinder/core/routing-strategies)**: Main routing strategies documentation
- **[PreferredWithFallbackRoutingStrategy](/wayfinder/core/routing-strategies/preferred-with-fallback)**: Reliable preferred gateway strategy
- **[Gateway Providers](/wayfinder/core/gateway-providers)**: Gateway discovery and management
- **[Events System](/wayfinder/core/events)**: Event handling and monitoring
