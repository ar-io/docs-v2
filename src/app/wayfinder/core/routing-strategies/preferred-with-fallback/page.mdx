import { Table } from '@/components/Table'

# PreferredWithFallbackRoutingStrategy

## Overview

The `PreferredWithFallbackRoutingStrategy` is a reliability-focused routing strategy that tries a preferred gateway first and falls back to alternative strategies when the preferred option fails. This strategy is ideal for applications with dedicated infrastructure that need reliable fallback options.

It's particularly useful for enterprise environments, CDN setups, and hybrid cloud deployments where you have a primary gateway but need intelligent failover capabilities.

## Configuration

### Basic Configuration

```javascript
import {
  PreferredWithFallbackRoutingStrategy,
  FastestPingRoutingStrategy,
} from '@ar.io/wayfinder-core'

const strategy = new PreferredWithFallbackRoutingStrategy({
  preferredGateway: 'https://my-gateway.com',
  fallbackStrategy: new FastestPingRoutingStrategy(),
})
```

### Advanced Configuration

```javascript
const strategy = new PreferredWithFallbackRoutingStrategy({
  preferredGateway: 'https://my-gateway.com',
  fallbackStrategy: new FastestPingRoutingStrategy({
    timeoutMs: 2000,
    cacheResultsMs: 30000,
  }),
  healthCheckEnabled: true,
  healthCheckPath: '/ar-io/info',
  healthCheckTimeoutMs: 3000,
  healthCheckIntervalMs: 60000,
  circuitBreakerEnabled: true,
  circuitBreakerThreshold: 5,
  circuitBreakerTimeoutMs: 30000,
  retryAttempts: 3,
  retryDelayMs: 1000,
  preferredGatewayWeight: 0.8,
  failureWindowMs: 300000,
  maxFailuresInWindow: 10,
})
```

## Configuration Options

### Core Options

<Table>
  <Table.Head>
    <Table.Row>
      <Table.Header>Option</Table.Header>
      <Table.Header>Type</Table.Header>
      <Table.Header>Default</Table.Header>
      <Table.Header>Description</Table.Header>
    </Table.Row>
  </Table.Head>
  <Table.Body>
    <Table.Row>
      <Table.Cell>`preferredGateway`</Table.Cell>
      <Table.Cell>string</Table.Cell>
      <Table.Cell>**Required**</Table.Cell>
      <Table.Cell>URL of the preferred gateway</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`fallbackStrategy`</Table.Cell>
      <Table.Cell>RoutingStrategy</Table.Cell>
      <Table.Cell>**Required**</Table.Cell>
      <Table.Cell>Strategy to use when preferred gateway fails</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`healthCheckEnabled`</Table.Cell>
      <Table.Cell>boolean</Table.Cell>
      <Table.Cell>true</Table.Cell>
      <Table.Cell>Enable health checks for preferred gateway</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`healthCheckPath`</Table.Cell>
      <Table.Cell>string</Table.Cell>
      <Table.Cell>'/ar-io/info'</Table.Cell>
      <Table.Cell>Endpoint path for health checks</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

### Health Check Options

<Table>
  <Table.Head>
    <Table.Row>
      <Table.Header>Option</Table.Header>
      <Table.Header>Type</Table.Header>
      <Table.Header>Default</Table.Header>
      <Table.Header>Description</Table.Header>
    </Table.Row>
  </Table.Head>
  <Table.Body>
    <Table.Row>
      <Table.Cell>`healthCheckTimeoutMs`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>2000</Table.Cell>
      <Table.Cell>Timeout for health check requests</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`healthCheckIntervalMs`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>30000</Table.Cell>
      <Table.Cell>Interval between background health checks</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`retryAttempts`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>2</Table.Cell>
      <Table.Cell>Number of retry attempts for failed requests</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`retryDelayMs`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>500</Table.Cell>
      <Table.Cell>Delay between retry attempts</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

### Circuit Breaker Options

<Table>
  <Table.Head>
    <Table.Row>
      <Table.Header>Option</Table.Header>
      <Table.Header>Type</Table.Header>
      <Table.Header>Default</Table.Header>
      <Table.Header>Description</Table.Header>
    </Table.Row>
  </Table.Head>
  <Table.Body>
    <Table.Row>
      <Table.Cell>`circuitBreakerEnabled`</Table.Cell>
      <Table.Cell>boolean</Table.Cell>
      <Table.Cell>false</Table.Cell>
      <Table.Cell>Enable circuit breaker pattern</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`circuitBreakerThreshold`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>5</Table.Cell>
      <Table.Cell>Failures before opening circuit</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`circuitBreakerTimeoutMs`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>30000</Table.Cell>
      <Table.Cell>Reset timeout for circuit breaker</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`failureWindowMs`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>60000</Table.Cell>
      <Table.Cell>Time window for failure counting</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`maxFailuresInWindow`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>10</Table.Cell>
      <Table.Cell>Max failures allowed in window</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

### Advanced Options

<Table>
  <Table.Head>
    <Table.Row>
      <Table.Header>Option</Table.Header>
      <Table.Header>Type</Table.Header>
      <Table.Header>Default</Table.Header>
      <Table.Header>Description</Table.Header>
    </Table.Row>
  </Table.Head>
  <Table.Body>
    <Table.Row>
      <Table.Cell>`preferredGatewayWeight`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>1.0</Table.Cell>
      <Table.Cell>Weight preference for primary gateway (0-1)</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`fallbackDelay`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>0</Table.Cell>
      <Table.Cell>Delay before attempting fallback strategy</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`stickiness`</Table.Cell>
      <Table.Cell>boolean</Table.Cell>
      <Table.Cell>false</Table.Cell>
      <Table.Cell>
        Remember successful fallback for subsequent requests
      </Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

## Usage Examples

### Basic Usage

```javascript
import {
  Wayfinder,
  PreferredWithFallbackRoutingStrategy,
  RandomRoutingStrategy,
} from '@ar.io/wayfinder-core'

const wayfinder = new Wayfinder({
  routingStrategy: new PreferredWithFallbackRoutingStrategy({
    preferredGateway: 'https://my-primary-gateway.com',
    fallbackStrategy: new RandomRoutingStrategy(),
  }),
})

// Will try preferred gateway first, fallback if it fails
const result = await wayfinder.request('/tx/transaction-id')
```

### Enterprise Configuration

```javascript
// Production setup with comprehensive monitoring
const strategy = new PreferredWithFallbackRoutingStrategy({
  preferredGateway: process.env.PRIMARY_GATEWAY_URL,
  fallbackStrategy: new FastestPingRoutingStrategy({
    timeoutMs: 2000,
    cacheResultsMs: 60000,
    concurrentPings: 5,
  }),
  healthCheckEnabled: true,
  healthCheckPath: '/ar-io/healthcheck',
  healthCheckTimeoutMs: 5000,
  healthCheckIntervalMs: 30000,
  circuitBreakerEnabled: true,
  circuitBreakerThreshold: 3,
  circuitBreakerTimeoutMs: 60000,
  retryAttempts: 3,
  retryDelayMs: 2000,
  failureWindowMs: 300000,
  maxFailuresInWindow: 5,
})

const wayfinder = new Wayfinder({
  routingStrategy: strategy,
})
```

### Multi-Tier Fallback Configuration

```javascript
import {
  PreferredWithFallbackRoutingStrategy,
  FastestPingRoutingStrategy,
  RoundRobinRoutingStrategy,
  StaticGatewaysProvider,
} from '@ar.io/wayfinder-core'

// Create nested fallback strategies
const tertiaryFallback = new StaticGatewaysProvider({
  gateways: ['https://arweave.net', 'https://ar-io.net'],
})

const secondaryFallback = new PreferredWithFallbackRoutingStrategy({
  preferredGateway: 'https://backup-gateway.com',
  fallbackStrategy: new RoundRobinRoutingStrategy(),
  circuitBreakerEnabled: true,
})

const primaryStrategy = new PreferredWithFallbackRoutingStrategy({
  preferredGateway: 'https://primary-gateway.com',
  fallbackStrategy: secondaryFallback,
  healthCheckEnabled: true,
  circuitBreakerEnabled: true,
  circuitBreakerThreshold: 2, // Fast failover
})

const wayfinder = new Wayfinder({
  routingStrategy: primaryStrategy,
})
```

### Geographic Failover Configuration

```javascript
// Geographic primary/fallback setup
const strategy = new PreferredWithFallbackRoutingStrategy({
  preferredGateway: 'https://us-east.my-company.com',
  fallbackStrategy: new PreferredWithFallbackRoutingStrategy({
    preferredGateway: 'https://us-west.my-company.com',
    fallbackStrategy: new FastestPingRoutingStrategy(),
  }),
  healthCheckEnabled: true,
  circuitBreakerEnabled: true,
  stickiness: true, // Remember which region works best
})
```

## Advanced Features

### Custom Health Check Logic

```javascript
class CustomHealthCheckStrategy extends PreferredWithFallbackRoutingStrategy {
  constructor(options) {
    super(options)
    this.customHealthChecks = options.customHealthChecks || {}
    this.healthMetrics = new Map()
  }

  async performHealthCheck(gateway) {
    const customCheck = this.customHealthChecks[gateway]
    if (customCheck) {
      try {
        const startTime = Date.now()
        const result = await customCheck(gateway)
        const responseTime = Date.now() - startTime

        this.updateHealthMetrics(gateway, true, responseTime)
        return result
      } catch (error) {
        this.updateHealthMetrics(gateway, false, null)
        throw error
      }
    }

    // Fallback to standard health check
    return super.performHealthCheck(gateway)
  }

  updateHealthMetrics(gateway, success, responseTime) {
    if (!this.healthMetrics.has(gateway)) {
      this.healthMetrics.set(gateway, {
        totalChecks: 0,
        successfulChecks: 0,
        totalResponseTime: 0,
        lastCheck: null,
      })
    }

    const metrics = this.healthMetrics.get(gateway)
    metrics.totalChecks++
    metrics.lastCheck = Date.now()

    if (success) {
      metrics.successfulChecks++
      if (responseTime) {
        metrics.totalResponseTime += responseTime
      }
    }
  }

  getHealthMetrics(gateway) {
    const metrics = this.healthMetrics.get(gateway)
    if (!metrics) return null

    return {
      successRate: metrics.successfulChecks / metrics.totalChecks,
      averageResponseTime: metrics.totalResponseTime / metrics.successfulChecks,
      totalChecks: metrics.totalChecks,
      lastCheck: metrics.lastCheck,
    }
  }
}

// Usage with custom health checks
const strategy = new CustomHealthCheckStrategy({
  preferredGateway: 'https://my-gateway.com',
  fallbackStrategy: new FastestPingRoutingStrategy(),
  customHealthChecks: {
    'https://my-gateway.com': async (gateway) => {
      // Custom health check logic
      const response = await fetch(`${gateway}/api/health`, {
        method: 'GET',
        timeout: 3000,
      })

      const data = await response.json()

      // Check multiple health indicators
      return (
        response.ok &&
        data.status === 'healthy' &&
        data.load < 0.8 &&
        data.memory < 0.9 &&
        data.responseTime < 1000
      )
    },
  },
})
```

### Intelligent Fallback Selection

```javascript
class IntelligentFallbackStrategy extends PreferredWithFallbackRoutingStrategy {
  constructor(options) {
    super(options)
    this.fallbackPerformanceHistory = new Map()
    this.learningEnabled = options.learningEnabled !== false
  }

  async selectFallbackGateway(context) {
    if (!this.learningEnabled) {
      return super.selectFallbackGateway(context)
    }

    // Analyze fallback performance history
    const fallbackStrategies = this.getFallbackStrategies()
    const performanceScores = await Promise.all(
      fallbackStrategies.map(async (strategy) => {
        const history =
          this.fallbackPerformanceHistory.get(strategy.constructor.name) || []
        const recentHistory = history.slice(-10) // Last 10 attempts

        if (recentHistory.length === 0) {
          return { strategy, score: 0.5 } // Neutral score for unknown strategies
        }

        const successRate =
          recentHistory.filter((h) => h.success).length / recentHistory.length
        const avgResponseTime =
          recentHistory
            .filter((h) => h.responseTime)
            .reduce((sum, h) => sum + h.responseTime, 0) /
            recentHistory.length || 1000

        // Calculate composite score (higher is better)
        const score = successRate * (1000 / avgResponseTime)
        return { strategy, score }
      }),
    )

    // Select best performing fallback strategy
    const bestStrategy = performanceScores.sort((a, b) => b.score - a.score)[0]
      .strategy

    return bestStrategy.selectGateway(context)
  }

  async onSuccess(gateway, context) {
    super.onSuccess && (await super.onSuccess(gateway, context))

    if (gateway !== this.preferredGateway) {
      this.recordFallbackPerformance(
        context.strategyUsed,
        true,
        context.responseTime,
      )
    }
  }

  async onFailure(gateway, error, context) {
    super.onFailure && (await super.onFailure(gateway, error, context))

    if (gateway !== this.preferredGateway) {
      this.recordFallbackPerformance(context.strategyUsed, false, null)
    }
  }

  recordFallbackPerformance(strategyName, success, responseTime) {
    if (!this.fallbackPerformanceHistory.has(strategyName)) {
      this.fallbackPerformanceHistory.set(strategyName, [])
    }

    const history = this.fallbackPerformanceHistory.get(strategyName)
    history.push({
      timestamp: Date.now(),
      success,
      responseTime,
    })

    // Keep only recent history (last 50 attempts)
    if (history.length > 50) {
      history.splice(0, history.length - 50)
    }
  }
}
```

### Sticky Fallback Strategy

```javascript
class StickyFallbackStrategy extends PreferredWithFallbackRoutingStrategy {
  constructor(options) {
    super(options)
    this.stickyGateway = null
    this.stickyTimeout = options.stickyTimeout || 300000 // 5 minutes
    this.stickySuccessThreshold = options.stickySuccessThreshold || 3
    this.currentStickySuccesses = 0
  }

  async selectGateway(context) {
    // Check if we have a sticky fallback gateway
    if (this.stickyGateway && this.isStickyGatewayValid()) {
      try {
        // Try the sticky gateway first
        if (await this.isGatewayHealthy(this.stickyGateway)) {
          return this.stickyGateway
        }
      } catch (error) {
        // Sticky gateway failed, clear it
        this.clearStickyGateway()
      }
    }

    // Try preferred gateway
    try {
      if (await this.isGatewayHealthy(this.preferredGateway)) {
        this.clearStickyGateway() // Reset sticky when preferred works
        return this.preferredGateway
      }
    } catch (error) {
      // Preferred gateway failed, try fallback
    }

    // Use fallback strategy
    const fallbackGateway = await this.fallbackStrategy.selectGateway(context)

    // Don't make preferred gateway sticky
    if (fallbackGateway !== this.preferredGateway) {
      this.setStickyGateway(fallbackGateway)
    }

    return fallbackGateway
  }

  async onSuccess(gateway, context) {
    super.onSuccess && (await super.onSuccess(gateway, context))

    if (gateway === this.stickyGateway) {
      this.currentStickySuccesses++

      // Extend sticky timeout on continued success
      if (this.currentStickySuccesses >= this.stickySuccessThreshold) {
        this.stickySince = Date.now()
        this.currentStickySuccesses = 0
      }
    }
  }

  setStickyGateway(gateway) {
    this.stickyGateway = gateway
    this.stickySince = Date.now()
    this.currentStickySuccesses = 0
  }

  clearStickyGateway() {
    this.stickyGateway = null
    this.stickySince = null
    this.currentStickySuccesses = 0
  }

  isStickyGatewayValid() {
    return (
      this.stickySince && Date.now() - this.stickySince < this.stickyTimeout
    )
  }
}

// Usage
const strategy = new StickyFallbackStrategy({
  preferredGateway: 'https://primary.com',
  fallbackStrategy: new FastestPingRoutingStrategy(),
  stickyTimeout: 600000, // 10 minutes
  stickySuccessThreshold: 5,
})
```

## Error Handling

### Common Error Types

```javascript
try {
  const gateway = await strategy.selectGateway(context)
  console.log('Selected gateway:', gateway)
} catch (error) {
  switch (error.code) {
    case 'PREFERRED_GATEWAY_UNHEALTHY':
      console.error('Preferred gateway failed health check')
      // Check gateway configuration or network connectivity
      break

    case 'FALLBACK_STRATEGY_FAILED':
      console.error('Fallback strategy could not select gateway')
      // All fallback options exhausted
      break

    case 'CIRCUIT_BREAKER_OPEN':
      console.error('Circuit breaker is open for preferred gateway')
      // Wait for circuit breaker reset or force reset
      break

    case 'HEALTH_CHECK_TIMEOUT':
      console.error('Health check timed out')
      // Increase timeout or check network latency
      break

    case 'MAX_RETRIES_EXCEEDED':
      console.error('Maximum retry attempts exceeded')
      // Increase retry limit or check gateway stability
      break

    default:
      console.error('Unknown preferred fallback error:', error.message)
  }
}
```

### Graceful Degradation

```javascript
class RobustPreferredFallbackStrategy extends PreferredWithFallbackRoutingStrategy {
  constructor(options) {
    super(options)
    this.emergencyGateways = options.emergencyGateways || [
      'https://arweave.net',
      'https://ar-io.net',
    ]
    this.degradedMode = false
  }

  async selectGateway(context) {
    try {
      return await super.selectGateway(context)
    } catch (error) {
      console.warn('Primary and fallback strategies failed:', error.message)

      // Enter degraded mode
      this.degradedMode = true

      // Try emergency gateways
      for (const gateway of this.emergencyGateways) {
        if (context.gateways.includes(gateway)) {
          try {
            if (await this.isGatewayHealthy(gateway)) {
              console.log('Using emergency gateway:', gateway)
              return gateway
            }
          } catch (emergencyError) {
            console.warn('Emergency gateway failed:', emergencyError.message)
          }
        }
      }

      // Last resort: return first available gateway
      if (context.gateways.length > 0) {
        console.warn('Using first available gateway as last resort')
        return context.gateways[0]
      }

      throw new Error('No gateways available')
    }
  }

  async onSuccess(gateway, context) {
    super.onSuccess && (await super.onSuccess(gateway, context))

    // Exit degraded mode on successful request
    if (this.degradedMode) {
      console.log('Exiting degraded mode')
      this.degradedMode = false
    }
  }
}
```

## Events and Monitoring

### Event Handling

```javascript
const strategy = new PreferredWithFallbackRoutingStrategy({
  preferredGateway: 'https://my-gateway.com',
  fallbackStrategy: new FastestPingRoutingStrategy(),
})

// Listen to strategy events
strategy.on('preferred:success', (gateway, responseTime) => {
  console.log(`Preferred gateway ${gateway} succeeded in ${responseTime}ms`)
})

strategy.on('preferred:failure', (gateway, error) => {
  console.error(`Preferred gateway ${gateway} failed: ${error.message}`)
})

strategy.on('fallback:activated', (reason, fallbackGateway) => {
  console.warn(`Fallback activated (${reason}), using: ${fallbackGateway}`)
})

strategy.on('circuit:opened', (gateway) => {
  console.error(`Circuit breaker opened for ${gateway}`)
})

strategy.on('circuit:closed', (gateway) => {
  console.log(`Circuit breaker closed for ${gateway}`)
})

strategy.on('health:check', (gateway, result) => {
  console.log(
    `Health check for ${gateway}: ${result.healthy ? 'PASS' : 'FAIL'}`,
  )
})
```

### Metrics Collection

```javascript
class MetricsEnabledPreferredStrategy extends PreferredWithFallbackRoutingStrategy {
  constructor(options) {
    super(options)
    this.metrics = {
      preferredSuccesses: 0,
      preferredFailures: 0,
      fallbackActivations: 0,
      circuitBreakerTriggers: 0,
      healthCheckFailures: 0,
      totalRequests: 0,
      averageResponseTime: 0,
      totalResponseTime: 0,
    }
  }

  async selectGateway(context) {
    this.metrics.totalRequests++
    const startTime = Date.now()

    try {
      const gateway = await super.selectGateway(context)
      const responseTime = Date.now() - startTime

      this.updateResponseTimeMetrics(responseTime)

      if (gateway === this.preferredGateway) {
        this.metrics.preferredSuccesses++
      } else {
        this.metrics.fallbackActivations++
      }

      return gateway
    } catch (error) {
      this.metrics.preferredFailures++
      throw error
    }
  }

  updateResponseTimeMetrics(responseTime) {
    this.metrics.totalResponseTime += responseTime
    this.metrics.averageResponseTime =
      this.metrics.totalResponseTime / this.metrics.totalRequests
  }

  getMetrics() {
    return {
      ...this.metrics,
      preferredSuccessRate:
        this.metrics.totalRequests > 0
          ? this.metrics.preferredSuccesses / this.metrics.totalRequests
          : 0,
      fallbackRate:
        this.metrics.totalRequests > 0
          ? this.metrics.fallbackActivations / this.metrics.totalRequests
          : 0,
    }
  }

  resetMetrics() {
    Object.keys(this.metrics).forEach((key) => {
      this.metrics[key] = 0
    })
  }
}

// Usage with metrics
const strategy = new MetricsEnabledPreferredStrategy({
  preferredGateway: 'https://my-gateway.com',
  fallbackStrategy: new FastestPingRoutingStrategy(),
})

// Log metrics periodically
setInterval(() => {
  const metrics = strategy.getMetrics()
  console.log('Preferred Fallback Metrics:', metrics)
}, 60000)
```

## Testing

### Unit Testing

```javascript
import {
  PreferredWithFallbackRoutingStrategy,
  RandomRoutingStrategy,
} from '@ar.io/wayfinder-core'

describe('PreferredWithFallbackRoutingStrategy', () => {
  let strategy
  let mockFallbackStrategy

  beforeEach(() => {
    mockFallbackStrategy = {
      selectGateway: jest.fn().mockResolvedValue('https://fallback.com'),
    }

    strategy = new PreferredWithFallbackRoutingStrategy({
      preferredGateway: 'https://preferred.com',
      fallbackStrategy: mockFallbackStrategy,
      healthCheckEnabled: false, // Disable for testing
    })
  })

  test('should use preferred gateway when healthy', async () => {
    const context = {
      gateways: ['https://preferred.com', 'https://fallback.com'],
      request: { url: '/test', method: 'GET' },
      attempt: 1,
      previousErrors: [],
    }

    strategy.isGatewayHealthy = jest.fn().mockResolvedValue(true)

    const selected = await strategy.selectGateway(context)
    expect(selected).toBe('https://preferred.com')
    expect(mockFallbackStrategy.selectGateway).not.toHaveBeenCalled()
  })

  test('should use fallback when preferred gateway is unhealthy', async () => {
    const context = {
      gateways: ['https://preferred.com', 'https://fallback.com'],
      request: { url: '/test', method: 'GET' },
      attempt: 1,
      previousErrors: [],
    }

    strategy.isGatewayHealthy = jest
      .fn()
      .mockResolvedValueOnce(false) // Preferred gateway unhealthy
      .mockResolvedValueOnce(true) // Fallback gateway healthy

    const selected = await strategy.selectGateway(context)
    expect(selected).toBe('https://fallback.com')
    expect(mockFallbackStrategy.selectGateway).toHaveBeenCalledWith(context)
  })

  test('should handle circuit breaker', async () => {
    strategy.circuitBreakerEnabled = true
    strategy.circuitBreakerThreshold = 2

    const context = {
      gateways: ['https://preferred.com'],
      request: { url: '/test', method: 'GET' },
      attempt: 1,
      previousErrors: [],
    }

    // Simulate failures to trigger circuit breaker
    strategy.isGatewayHealthy = jest
      .fn()
      .mockRejectedValue(new Error('Health check failed'))

    // First failure
    await expect(strategy.selectGateway(context)).rejects.toThrow()

    // Second failure should open circuit
    await expect(strategy.selectGateway(context)).rejects.toThrow()

    // Third call should not even attempt health check
    strategy.isGatewayHealthy.mockClear()
    await expect(strategy.selectGateway(context)).rejects.toThrow()
    expect(strategy.isGatewayHealthy).not.toHaveBeenCalled()
  })
})
```

### Integration Testing

```javascript
describe('PreferredWithFallbackRoutingStrategy Integration', () => {
  test('should work with real gateways', async () => {
    const strategy = new PreferredWithFallbackRoutingStrategy({
      preferredGateway: 'https://arweave.net',
      fallbackStrategy: new RandomRoutingStrategy(),
      healthCheckEnabled: true,
      healthCheckTimeoutMs: 5000,
    })

    const context = {
      gateways: ['https://arweave.net', 'https://ar-io.net'],
      request: { url: '/ar-io/info', method: 'GET' },
      attempt: 1,
      previousErrors: [],
    }

    const selected = await strategy.selectGateway(context)
    expect(selected).toBeDefined()
    expect(context.gateways).toContain(selected)
  }, 10000)
})
```

## Best Practices

1. **Choose Reliable Preferred Gateways**: Select gateways with high uptime and performance
2. **Configure Appropriate Health Checks**: Balance frequency with performance overhead
3. **Use Circuit Breakers**: Prevent repeatedly hitting failed gateways
4. **Monitor Fallback Activation**: Track when and why fallbacks are triggered
5. **Test Failover Scenarios**: Regularly test gateway failure scenarios
6. **Set Realistic Timeouts**: Balance responsiveness with reliability
7. **Implement Sticky Behavior**: Remember successful fallbacks for performance
8. **Plan Multi-Tier Fallbacks**: Consider nested fallback strategies for redundancy

## Performance Considerations

- **Health Check Overhead**: Background health checks consume resources
- **Failover Latency**: Time to detect failures and switch to fallback
- **Circuit Breaker State**: Track and manage circuit breaker state across requests
- **Fallback Strategy Performance**: Ensure fallback strategies are well-optimized
- **Sticky Gateway Memory**: Balance stickiness with adaptive behavior

## Related Documentation

- **[Routing Strategies Overview](/wayfinder/core/routing-strategies)**: Main routing strategies documentation
- **[FastestPingRoutingStrategy](/wayfinder/core/routing-strategies/fastest-ping)**: Performance-optimized gateway selection
- **[RoundRobinRoutingStrategy](/wayfinder/core/routing-strategies/round-robin)**: Even load distribution strategy
- **[Gateway Providers](/wayfinder/core/gateway-providers)**: Gateway discovery and management
- **[Events System](/wayfinder/core/events)**: Event handling and monitoring
