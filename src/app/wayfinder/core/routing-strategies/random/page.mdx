import { Table } from '@/components/Table'

# RandomRoutingStrategy

## Overview

The `RandomRoutingStrategy` is a simple routing strategy that randomly selects gateways from the available options. It provides straightforward load distribution without maintaining complex state or performing expensive calculations, making it ideal for situations where simplicity and unpredictability are preferred.

This strategy is particularly useful for development environments, testing scenarios, and applications that want to avoid patterns in gateway selection.

## Configuration

### Basic Configuration

```javascript
import { RandomRoutingStrategy } from '@ar.io/wayfinder-core'

const strategy = new RandomRoutingStrategy({
  healthCheckEnabled: true,
  seed: null, // Use random seed
})
```

### Advanced Configuration

```javascript
const strategy = new RandomRoutingStrategy({
  healthCheckEnabled: true,
  healthCheckPath: '/ar-io/info',
  healthCheckTimeoutMs: 2000,
  weightedSelection: true,
  weights: new Map([
    ['https://high-capacity.com', 3],
    ['https://standard-capacity.com', 1],
  ]),
  seed: 12345, // For reproducible randomness in testing
  skipUnhealthyGateways: true,
})
```

## Configuration Options

### Core Options

<Table>
  <Table.Head>
    <Table.Row>
      <Table.Header>Option</Table.Header>
      <Table.Header>Type</Table.Header>
      <Table.Header>Default</Table.Header>
      <Table.Header>Description</Table.Header>
    </Table.Row>
  </Table.Head>
  <Table.Body>
    <Table.Row>
      <Table.Cell>`healthCheckEnabled`</Table.Cell>
      <Table.Cell>boolean</Table.Cell>
      <Table.Cell>true</Table.Cell>
      <Table.Cell>Enable health checks for gateways</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`weightedSelection`</Table.Cell>
      <Table.Cell>boolean</Table.Cell>
      <Table.Cell>false</Table.Cell>
      <Table.Cell>Use weighted random selection</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`seed`</Table.Cell>
      <Table.Cell>number | null</Table.Cell>
      <Table.Cell>null</Table.Cell>
      <Table.Cell>Random seed for reproducible testing</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`skipUnhealthyGateways`</Table.Cell>
      <Table.Cell>boolean</Table.Cell>
      <Table.Cell>true</Table.Cell>
      <Table.Cell>Skip gateways that fail health checks</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

### Advanced Options

<Table>
  <Table.Head>
    <Table.Row>
      <Table.Header>Option</Table.Header>
      <Table.Header>Type</Table.Header>
      <Table.Header>Default</Table.Header>
      <Table.Header>Description</Table.Header>
    </Table.Row>
  </Table.Head>
  <Table.Body>
    <Table.Row>
      <Table.Cell>`weights`</Table.Cell>
      <Table.Cell>Map&lt;string, number&gt;</Table.Cell>
      <Table.Cell>null</Table.Cell>
      <Table.Cell>Gateway weights for weighted selection</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`healthCheckPath`</Table.Cell>
      <Table.Cell>string</Table.Cell>
      <Table.Cell>'/ar-io/info'</Table.Cell>
      <Table.Cell>Endpoint path for health checks</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>`healthCheckTimeoutMs`</Table.Cell>
      <Table.Cell>number</Table.Cell>
      <Table.Cell>2000</Table.Cell>
      <Table.Cell>Timeout for health check requests</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

## Usage Examples

### Basic Usage

```javascript
import { Wayfinder, RandomRoutingStrategy } from '@ar.io/wayfinder-core'

const wayfinder = new Wayfinder({
  routingStrategy: new RandomRoutingStrategy({
    healthCheckEnabled: true,
  }),
})

// Each request will randomly select from available gateways
const result1 = await wayfinder.request('/tx/transaction-id-1') // Random gateway
const result2 = await wayfinder.request('/tx/transaction-id-2') // Random gateway
const result3 = await wayfinder.request('/tx/transaction-id-3') // Random gateway
```

### Weighted Random Selection

```javascript
// Distribute load based on gateway capacity with randomness
const strategy = new RandomRoutingStrategy({
  weightedSelection: true,
  weights: new Map([
    ['https://high-capacity-gateway.com', 4], // 4x more likely to be selected
    ['https://medium-capacity-gateway.com', 2], // 2x more likely to be selected
    ['https://low-capacity-gateway.com', 1], // 1x likelihood (baseline)
  ]),
  healthCheckEnabled: true,
  skipUnhealthyGateways: true,
})

const wayfinder = new Wayfinder({
  routingStrategy: strategy,
})
```

### Development Configuration with Reproducible Randomness

```javascript
// For testing and development with predictable behavior
const strategy = new RandomRoutingStrategy({
  seed: 42, // Fixed seed for reproducible results
  healthCheckEnabled: false, // Disable health checks for faster testing
})

const wayfinder = new Wayfinder({
  routingStrategy: strategy,
})
```

## Advanced Features

### Weighted Random Selection Implementation

```javascript
class WeightedRandomStrategy extends RandomRoutingStrategy {
  constructor(options) {
    super(options)
    this.setupWeightedSelection()
  }

  async selectGateway(context) {
    const availableGateways = this.skipUnhealthyGateways
      ? await this.filterHealthyGateways(context.gateways)
      : context.gateways

    if (availableGateways.length === 0) {
      throw new Error('No healthy gateways available')
    }

    if (!this.weightedSelection || !this.weights || this.weights.size === 0) {
      return this.selectRandomGateway(availableGateways)
    }

    return this.selectWeightedRandomGateway(availableGateways)
  }

  selectRandomGateway(gateways) {
    const randomIndex = Math.floor(this.getRandom() * gateways.length)
    return gateways[randomIndex]
  }

  selectWeightedRandomGateway(availableGateways) {
    // Filter weighted gateways to only include available ones
    const availableWeightedGateways = Array.from(this.weights.entries()).filter(
      ([gateway]) => availableGateways.includes(gateway),
    )

    if (availableWeightedGateways.length === 0) {
      return this.selectRandomGateway(availableGateways)
    }

    // Calculate total weight for available gateways
    const totalWeight = availableWeightedGateways.reduce(
      (sum, [, weight]) => sum + weight,
      0,
    )

    const randomValue = this.getRandom() * totalWeight
    let currentWeight = 0

    for (const [gateway, weight] of availableWeightedGateways) {
      currentWeight += weight
      if (randomValue <= currentWeight) {
        return gateway
      }
    }

    // Fallback to last gateway
    return availableWeightedGateways[availableWeightedGateways.length - 1][0]
  }

  getRandom() {
    // Use seeded random if configured, otherwise Math.random()
    if (this.seed !== null && this.seed !== undefined) {
      return this.seededRandom()
    }
    return Math.random()
  }

  seededRandom() {
    // Simple seeded random number generator for testing
    this.seed = (this.seed * 9301 + 49297) % 233280
    return this.seed / 233280
  }
}
```

## Error Handling

### Common Error Types

```javascript
try {
  const gateway = await strategy.selectGateway(context)
  console.log('Selected gateway:', gateway)
} catch (error) {
  switch (error.code) {
    case 'NO_HEALTHY_GATEWAYS':
      console.error('All gateways failed health checks')
      // Wait for gateways to recover or use emergency fallback
      break

    case 'WEIGHT_CONFIGURATION_INVALID':
      console.error('Invalid weight configuration')
      // Check gateway weight settings
      break

    case 'RANDOM_SELECTION_FAILED':
      console.error('Random selection algorithm failed')
      // Reset random state or use fallback selection
      break

    default:
      console.error('Unknown random strategy error:', error.message)
  }
}
```

### Graceful Degradation

```javascript
class RobustRandomStrategy extends RandomRoutingStrategy {
  constructor(options) {
    super(options)
    this.emergencyGateways = options.emergencyGateways || [
      'https://arweave.net',
    ]
  }

  async selectGateway(context) {
    try {
      return await super.selectGateway(context)
    } catch (error) {
      console.warn(
        'Random strategy failed, attempting recovery:',
        error.message,
      )

      // Try emergency gateways
      for (const gateway of this.emergencyGateways) {
        if (context.gateways.includes(gateway)) {
          console.log('Using emergency gateway:', gateway)
          return gateway
        }
      }

      // Last resort: return first available gateway
      if (context.gateways.length > 0) {
        console.warn('Using first available gateway as fallback')
        return context.gateways[0]
      }

      throw new Error('No gateways available for selection')
    }
  }
}
```

## Testing

### Unit Testing

```javascript
import { RandomRoutingStrategy } from '@ar.io/wayfinder-core'

describe('RandomRoutingStrategy', () => {
  let strategy

  beforeEach(() => {
    strategy = new RandomRoutingStrategy({
      healthCheckEnabled: false, // Disable for predictable testing
      seed: 42, // Fixed seed for reproducible results
    })
  })

  test('should select gateways randomly', async () => {
    const context = {
      gateways: [
        'https://gateway1.com',
        'https://gateway2.com',
        'https://gateway3.com',
      ],
      request: { url: '/test', method: 'GET' },
      attempt: 1,
      previousErrors: [],
    }

    const selections = []
    for (let i = 0; i < 100; i++) {
      const selected = await strategy.selectGateway(context)
      selections.push(selected)
      expect(context.gateways).toContain(selected)
    }

    // Check that all gateways were selected at least once
    const uniqueSelections = new Set(selections)
    expect(uniqueSelections.size).toBe(context.gateways.length)
  })

  test('should respect weighted selection', async () => {
    strategy.weightedSelection = true
    strategy.weights = new Map([
      ['https://gateway1.com', 3],
      ['https://gateway2.com', 1],
    ])

    const context = {
      gateways: ['https://gateway1.com', 'https://gateway2.com'],
      request: { url: '/test', method: 'GET' },
      attempt: 1,
      previousErrors: [],
    }

    const selections = []
    for (let i = 0; i < 400; i++) {
      selections.push(await strategy.selectGateway(context))
    }

    const gateway1Count = selections.filter(
      (g) => g === 'https://gateway1.com',
    ).length
    const gateway2Count = selections.filter(
      (g) => g === 'https://gateway2.com',
    ).length

    // Gateway1 should be selected roughly 3x more than Gateway2
    const ratio = gateway1Count / gateway2Count
    expect(ratio).toBeGreaterThan(2.5)
    expect(ratio).toBeLessThan(3.5)
  })
})
```

## Best Practices

1. **Use Appropriate Weights**: Set weights based on actual gateway capacity and performance
2. **Enable Health Checks**: Ensure random selection only includes healthy gateways
3. **Consider Seeded Randomness**: Use seeds for reproducible testing and debugging
4. **Monitor Distribution**: Track how requests are distributed over time
5. **Handle Edge Cases**: Ensure graceful handling when no gateways are available
6. **Balance Simplicity and Features**: Don't over-complicate random selection

## Performance Considerations

- **Selection Speed**: Random selection is typically very fast
- **Weight Calculation**: Complex weight calculations can slow selection
- **Health Check Overhead**: Background health checks consume resources
- **Randomness Quality**: Poor randomness can lead to uneven distribution

## Use Cases

### When to Use RandomRoutingStrategy

- **Development and Testing**: Simple, predictable behavior for testing
- **Load Distribution**: When even distribution is more important than optimization
- **Avoiding Patterns**: Preventing predictable request patterns
- **Fallback Strategy**: As a simple fallback when other strategies fail
- **Microservices**: When request routing needs to be stateless and simple

### When Not to Use RandomRoutingStrategy

- **Performance-Critical Applications**: Use FastestPingRoutingStrategy instead
- **Sticky Sessions Required**: Use strategies with session affinity
- **Geographic Optimization**: Use location-aware strategies
- **Complex Load Balancing**: Use RoundRobinRoutingStrategy for better control

## Related Documentation

- **[Routing Strategies Overview](/wayfinder/core/routing-strategies)**: Main routing strategies documentation
- **[FastestPingRoutingStrategy](/wayfinder/core/routing-strategies/fastest-ping)**: Performance-optimized gateway selection
- **[RoundRobinRoutingStrategy](/wayfinder/core/routing-strategies/round-robin)**: Even load distribution strategy
- **[PreferredWithFallbackRoutingStrategy](/wayfinder/core/routing-strategies/preferred-with-fallback)**: Reliable preferred gateway strategy
- **[Gateway Providers](/wayfinder/core/gateway-providers)**: Gateway discovery and management
- **[Events System](/wayfinder/core/events)**: Event handling and monitoring
