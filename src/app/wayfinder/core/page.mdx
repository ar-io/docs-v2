# Wayfinder Class

## Overview

The `Wayfinder` class is the main entry point for the wayfinder-core library. It orchestrates gateway discovery, routing strategies, data verification, and telemetry to provide intelligent access to the Arweave network through AR.IO gateways.

## Constructor

### Basic Usage

```javascript
import { Wayfinder, NetworkGatewaysProvider } from '@ar.io/wayfinder-core'
import { ARIO } from '@ar.io/sdk'

const wayfinder = new Wayfinder({
  gatewaysProvider: new NetworkGatewaysProvider({
    ario: ARIO.mainnet(),
  }),
})
```

### Full Configuration

```javascript
import {
  Wayfinder,
  NetworkGatewaysProvider,
  FastestPingRoutingStrategy,
  HashVerificationStrategy,
} from '@ar.io/wayfinder-core'
import { ARIO } from '@ar.io/sdk'

const wayfinder = new Wayfinder({
  gatewaysProvider: new NetworkGatewaysProvider({
    ario: ARIO.mainnet(),
  }),
  routingSettings: {
    strategy: new FastestPingRoutingStrategy({
      timeoutMs: 2000,
      cacheResultsMs: 30000,
    }),
    events: {
      onRoutingStarted: (event) =>
        console.log('Routing started:', event.originalUrl),
      onRoutingSucceeded: (event) =>
        console.log('Gateway selected:', event.selectedGateway),
      onRoutingFailed: (error) =>
        console.error('Routing failed:', error.message),
    },
  },
  verificationSettings: {
    enabled: true,
    strategy: new HashVerificationStrategy({
      trustedGateways: ['https://arweave.net'],
    }),
    strict: false,
    events: {
      onVerificationStarted: (event) => console.log('Verifying:', event.txId),
      onVerificationSucceeded: (event) =>
        console.log('Verification passed:', event.txId),
      onVerificationFailed: (error) =>
        console.warn('Verification failed:', error.message),
    },
  },
  telemetrySettings: {
    enabled: true,
    serviceName: 'my-application',
    sampleRate: 0.1,
    exporterUrl: 'https://api.honeycomb.io',
    apiKey: process.env.HONEYCOMB_API_KEY,
  },
  logger: {
    debug: (message, ...args) =>
      console.debug(`[WAYFINDER] ${message}`, ...args),
    info: (message, ...args) => console.info(`[WAYFINDER] ${message}`, ...args),
    warn: (message, ...args) => console.warn(`[WAYFINDER] ${message}`, ...args),
    error: (message, ...args) =>
      console.error(`[WAYFINDER] ${message}`, ...args),
  },
})
```

## Core Methods

### request()

Fetches data from Arweave using intelligent gateway routing and optional verification.

**Signature:**

```typescript
async request(url: string, options?: RequestOptions): Promise<Response>
```

**Parameters:**

- `url` (string): The ar:// URL or transaction ID to fetch
- `options` (RequestOptions, optional): Fetch options and wayfinder-specific settings

**Returns:** Promise&lt;Response&gt; - Standard fetch Response object

**Basic Usage:**

```javascript
// Fetch by transaction ID
const response = await wayfinder.request(
  'ar://bNbA3TEQVL60xlgCcqdz4ZPHFZ711cZ3hmkpGttDt_U',
)
const data = await response.text()

// Fetch with custom headers
const response = await wayfinder.request('ar://transaction-id', {
  headers: {
    Accept: 'application/json',
  },
})
const json = await response.json()

// Fetch with timeout
const response = await wayfinder.request('ar://transaction-id', {
  signal: AbortSignal.timeout(5000), // 5 second timeout
})
```

**Advanced Usage:**

```javascript
// Override routing strategy for specific request
const response = await wayfinder.request('ar://transaction-id', {
  wayfinderOptions: {
    routingStrategy: new PreferredWithFallbackRoutingStrategy({
      preferredGateway: 'https://my-preferred-gateway.com',
      fallbackStrategy: new FastestPingRoutingStrategy({ timeoutMs: 1000 }),
    }),
  },
})

// Disable verification for specific request
const response = await wayfinder.request('ar://transaction-id', {
  wayfinderOptions: {
    verificationEnabled: false,
  },
})

// Custom gateway selection
const response = await wayfinder.request('ar://transaction-id', {
  wayfinderOptions: {
    preferredGateways: ['https://gateway1.com', 'https://gateway2.com'],
  },
})
```

### resolveUrl()

Resolves an ar:// URL to a gateway URL without fetching the data.

**Signature:**

```typescript
async resolveUrl(url: string, options?: ResolveUrlOptions): Promise<string>
```

**Parameters:**

- `url` (string): The ar:// URL or transaction ID to resolve
- `options` (ResolveUrlOptions, optional): Resolution options

**Returns:** Promise&lt;string&gt; - The resolved gateway URL

**Usage:**

```javascript
// Basic URL resolution
const gatewayUrl = await wayfinder.resolveUrl(
  'ar://bNbA3TEQVL60xlgCcqdz4ZPHFZ711cZ3hmkpGttDt_U',
)
console.log(gatewayUrl) // https://arweave.net/bNbA3TEQVL60xlgCcqdz4ZPHFZ711cZ3hmkpGttDt_U

// Resolution with custom routing
const gatewayUrl = await wayfinder.resolveUrl('ar://transaction-id', {
  routingStrategy: new FastestPingRoutingStrategy({ timeoutMs: 1000 }),
})

// Resolution with preferred gateways
const gatewayUrl = await wayfinder.resolveUrl('ar://transaction-id', {
  preferredGateways: ['https://my-gateway.com'],
})
```

## Properties

### emitter

Event emitter for monitoring wayfinder operations.

**Type:** `EventEmitter`

**Usage:**

```javascript
// Listen to all routing events
wayfinder.emitter.on('routing-started', (event) => {
  console.log('Routing started for:', event.originalUrl)
})

wayfinder.emitter.on('routing-succeeded', (event) => {
  console.log('Selected gateway:', event.selectedGateway)
  console.log('Response time:', event.responseTime)
})

wayfinder.emitter.on('routing-failed', (error) => {
  console.error('Routing failed:', error.message)
})

// Listen to verification events
wayfinder.emitter.on('verification-started', (event) => {
  console.log('Verifying transaction:', event.txId)
})

wayfinder.emitter.on('verification-succeeded', (event) => {
  console.log('Verification passed for:', event.txId)
})

wayfinder.emitter.on('verification-failed', (error) => {
  console.warn('Verification failed:', error.message)
  console.warn('Transaction ID:', error.txId)
})

// Listen to telemetry events
wayfinder.emitter.on('telemetry-span-started', (event) => {
  console.log('Telemetry span started:', event.spanName)
})

wayfinder.emitter.on('telemetry-span-ended', (event) => {
  console.log('Telemetry span ended:', event.spanName, event.duration)
})
```

### gatewaysProvider

The configured gateways provider instance.

**Type:** `GatewaysProvider`

**Usage:**

```javascript
// Get current gateways
const gateways = await wayfinder.gatewaysProvider.getGateways()
console.log('Available gateways:', gateways)

// Refresh gateway list (if supported by provider)
if (wayfinder.gatewaysProvider.refresh) {
  await wayfinder.gatewaysProvider.refresh()
}
```

### routingStrategy

The configured routing strategy instance.

**Type:** `RoutingStrategy`

**Usage:**

```javascript
// Get current routing strategy
console.log(
  'Current routing strategy:',
  wayfinder.routingStrategy.constructor.name,
)

// Manually select gateway using current strategy
const gateways = await wayfinder.gatewaysProvider.getGateways()
const selectedGateway = await wayfinder.routingStrategy.selectGateway({
  gateways,
})
console.log('Selected gateway:', selectedGateway)
```

### verificationStrategy

The configured verification strategy instance (if verification is enabled).

**Type:** `VerificationStrategy | null`

**Usage:**

```javascript
if (wayfinder.verificationStrategy) {
  console.log(
    'Verification enabled with:',
    wayfinder.verificationStrategy.constructor.name,
  )

  // Manually verify data
  const isValid = await wayfinder.verificationStrategy.verifyData({
    data: new Uint8Array([1, 2, 3]),
    txId: 'transaction-id',
    gateway: 'https://arweave.net',
  })
  console.log('Data is valid:', isValid)
} else {
  console.log('Verification is disabled')
}
```

## Configuration Options

### WayfinderOptions Interface

```typescript
interface WayfinderOptions {
  gatewaysProvider: GatewaysProvider
  routingSettings?: {
    strategy?: RoutingStrategy
    events?: WayfinderRoutingEventArgs
  }
  verificationSettings?: {
    enabled?: boolean
    strategy?: VerificationStrategy
    strict?: boolean
    events?: WayfinderVerificationEventArgs
  }
  telemetrySettings?: TelemetryConfig
  logger?: Logger
}
```

### RequestOptions Interface

```typescript
interface RequestOptions extends RequestInit {
  wayfinderOptions?: {
    routingStrategy?: RoutingStrategy
    verificationEnabled?: boolean
    verificationStrategy?: VerificationStrategy
    preferredGateways?: string[]
    timeout?: number
  }
}
```

### ResolveUrlOptions Interface

```typescript
interface ResolveUrlOptions {
  routingStrategy?: RoutingStrategy
  preferredGateways?: string[]
  timeout?: number
}
```

## Advanced Usage Patterns

### Custom Error Handling

```javascript
import {
  WayfinderError,
  RoutingError,
  VerificationError,
  GatewayError,
  TimeoutError,
} from '@ar.io/wayfinder-core'

try {
  const response = await wayfinder.request('ar://transaction-id')
  const data = await response.text()
} catch (error) {
  if (error instanceof RoutingError) {
    console.error('Failed to select gateway:', error.message)
    // Retry with different strategy or fallback to static gateway
  } else if (error instanceof VerificationError) {
    console.error('Data verification failed:', error.message)
    // Decide whether to trust unverified data or retry
  } else if (error instanceof GatewayError) {
    console.error('Gateway communication failed:', error.message)
    // Try different gateway or check network connectivity
  } else if (error instanceof TimeoutError) {
    console.error('Request timed out:', error.message)
    // Increase timeout or try faster gateway
  } else {
    console.error('Unexpected error:', error.message)
  }
}
```

### Performance Monitoring

```javascript
class PerformanceMonitor {
  constructor(wayfinder) {
    this.wayfinder = wayfinder
    this.metrics = {
      requestCount: 0,
      totalResponseTime: 0,
      gatewayUsage: new Map(),
      verificationResults: { passed: 0, failed: 0 },
    }

    this.setupEventListeners()
  }

  setupEventListeners() {
    this.wayfinder.emitter.on('routing-succeeded', (event) => {
      this.metrics.requestCount++
      this.metrics.totalResponseTime += event.responseTime

      const usage = this.metrics.gatewayUsage.get(event.selectedGateway) || 0
      this.metrics.gatewayUsage.set(event.selectedGateway, usage + 1)
    })

    this.wayfinder.emitter.on('verification-succeeded', () => {
      this.metrics.verificationResults.passed++
    })

    this.wayfinder.emitter.on('verification-failed', () => {
      this.metrics.verificationResults.failed++
    })
  }

  getStats() {
    return {
      averageResponseTime:
        this.metrics.totalResponseTime / this.metrics.requestCount,
      requestCount: this.metrics.requestCount,
      gatewayUsage: Object.fromEntries(this.metrics.gatewayUsage),
      verificationSuccessRate:
        this.metrics.verificationResults.passed /
        (this.metrics.verificationResults.passed +
          this.metrics.verificationResults.failed),
    }
  }
}

const monitor = new PerformanceMonitor(wayfinder)

// Later, get performance statistics
console.log('Performance stats:', monitor.getStats())
```

### Request Batching

```javascript
class BatchedWayfinder {
  constructor(wayfinder, batchSize = 10, batchDelayMs = 100) {
    this.wayfinder = wayfinder
    this.batchSize = batchSize
    this.batchDelayMs = batchDelayMs
    this.pendingRequests = []
    this.batchTimer = null
  }

  async request(url, options = {}) {
    return new Promise((resolve, reject) => {
      this.pendingRequests.push({ url, options, resolve, reject })

      if (this.pendingRequests.length >= this.batchSize) {
        this.processBatch()
      } else if (!this.batchTimer) {
        this.batchTimer = setTimeout(
          () => this.processBatch(),
          this.batchDelayMs,
        )
      }
    })
  }

  async processBatch() {
    if (this.batchTimer) {
      clearTimeout(this.batchTimer)
      this.batchTimer = null
    }

    const batch = this.pendingRequests.splice(0, this.batchSize)

    // Process requests in parallel with shared gateway selection
    const gateways = await this.wayfinder.gatewaysProvider.getGateways()
    const selectedGateway = await this.wayfinder.routingStrategy.selectGateway({
      gateways,
    })

    const promises = batch.map(async ({ url, options, resolve, reject }) => {
      try {
        // Use the same gateway for all requests in the batch
        const gatewayUrl = `${selectedGateway}/${url.replace('ar://', '')}`
        const response = await fetch(gatewayUrl, options)
        resolve(response)
      } catch (error) {
        reject(error)
      }
    })

    await Promise.allSettled(promises)
  }
}

const batchedWayfinder = new BatchedWayfinder(wayfinder, 5, 50)

// Requests will be batched automatically
const responses = await Promise.all([
  batchedWayfinder.request('ar://tx1'),
  batchedWayfinder.request('ar://tx2'),
  batchedWayfinder.request('ar://tx3'),
  batchedWayfinder.request('ar://tx4'),
  batchedWayfinder.request('ar://tx5'),
])
```

### Caching Layer

```javascript
class CachedWayfinder {
  constructor(wayfinder, cacheOptions = {}) {
    this.wayfinder = wayfinder
    this.cache = new Map()
    this.cacheTtl = cacheOptions.ttl || 60000 // 1 minute default
    this.maxCacheSize = cacheOptions.maxSize || 1000
  }

  async request(url, options = {}) {
    const cacheKey = this.getCacheKey(url, options)
    const cached = this.cache.get(cacheKey)

    if (cached && Date.now() - cached.timestamp < this.cacheTtl) {
      console.log('Cache hit for:', url)
      return cached.response.clone()
    }

    const response = await this.wayfinder.request(url, options)

    // Only cache successful responses
    if (response.ok) {
      this.setCacheEntry(cacheKey, response.clone())
    }

    return response
  }

  getCacheKey(url, options) {
    return `${url}-${JSON.stringify(options)}`
  }

  setCacheEntry(key, response) {
    // Implement LRU eviction if cache is full
    if (this.cache.size >= this.maxCacheSize) {
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }

    this.cache.set(key, {
      response,
      timestamp: Date.now(),
    })
  }

  clearCache() {
    this.cache.clear()
  }

  getCacheStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxCacheSize,
      hitRate: this.hitCount / (this.hitCount + this.missCount) || 0,
    }
  }
}

const cachedWayfinder = new CachedWayfinder(wayfinder, {
  ttl: 300000, // 5 minutes
  maxSize: 500,
})

// Subsequent requests for the same URL will be served from cache
const response1 = await cachedWayfinder.request('ar://transaction-id')
const response2 = await cachedWayfinder.request('ar://transaction-id') // Cache hit
```

## Best Practices

1. **Configure Appropriate Timeouts**: Set timeouts based on your application's requirements
2. **Enable Telemetry in Production**: Use telemetry to monitor performance and identify issues
3. **Handle Errors Gracefully**: Implement proper error handling for different failure scenarios
4. **Use Verification for Critical Data**: Enable verification for important or sensitive data
5. **Monitor Gateway Performance**: Track which gateways perform best for your use case
6. **Cache Gateway Lists**: Use cached gateway providers to reduce discovery overhead
7. **Implement Request Retries**: Add retry logic for transient failures
8. **Log Important Events**: Use the event system to log important operations

## Related Documentation

- **[Constructor Details](#constructor)**: Detailed constructor options and examples
- **[request() Method](/wayfinder/core/request)**: Comprehensive request method documentation
- **[resolveUrl() Method](/wayfinder/core/resolve-url)**: URL resolution method details
- **[Events System](/wayfinder/core/events)**: Event handling and monitoring
- **[Gateway Providers](/wayfinder/core/gateway-providers)**: Gateway discovery and management
- **[Routing Strategies](/wayfinder/routing-strategies)**: Gateway selection algorithms
- **[Verification Strategies](/wayfinder/verification-strategies)**: Data integrity verification
