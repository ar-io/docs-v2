---
title: "Strategy Composition Examples"
description: "JavaScript/TypeScript SDK for accessing Arweave data with built-in verification and gateway routing"
---

Here are a few “lego-style” examples showing how existing routing strategies can
be composed to suit different use cases. Each strategy implements
`RoutingStrategy`, so they can be wrapped and combined freely.

#### Random + Ping health checks

Pick a random gateway, then verify it responds with a `HEAD` request before
returning it.

```ts
import {
  RandomRoutingStrategy,
  PingRoutingStrategy,
} from "@ar.io/wayfinder-core";

const strategy = new PingRoutingStrategy({
  routingStrategy: new RandomRoutingStrategy(),
  retries: 2,
  timeoutMs: 500,
});
```

#### Fastest ping wrapped with a simple cache

Find the lowest-latency gateway and cache the result for five minutes to avoid
constant pings.

```ts
import {
  FastestPingRoutingStrategy,
  SimpleCacheRoutingStrategy,
} from "@ar.io/wayfinder-core";

const strategy = new SimpleCacheRoutingStrategy({
  routingStrategy: new FastestPingRoutingStrategy({ timeoutMs: 500 }),
  ttlSeconds: 300,
});
```

#### Preferred gateway + network fallback strategy

Attempt to use a favorite gateway, but fallback to a fastest pinging strategy using the ARIO Network if it fails.

```ts
import {
  PreferredWithFallbackRoutingStrategy,
  RandomRoutingStrategy,
  PingRoutingStrategy,
  NetworkGatewaysProvider,
} from "@ar.io/wayfinder-core";
import { ARIO } from '@ar.io/sdk';

// these will be our fallback gateways
const gatewayProvider = new NetworkGatewaysProvider({
  ario: ARIO.mainnet(),
  sortBy: 'operatorStake',
  limit: 5,
});

// this is our fallback strategy if our preferred gateway fails
const fastestPingStrategy = new FastestPingRoutingStrategy({
  timeoutMs: 500,
  gatewaysProvider: gatewayProvider,
});

// compose the strategies together, the preferred gateway will be used first, and if it fails, the fallback strategy will be used.
const strategy = new PreferredWithFallbackRoutingStrategy({
  preferredGateway: "https://my-gateway.example",
  fallbackStrategy: fastestPingStrategy,
});
```

#### Round-robin + ping verification

Cycle through gateways sequentially, checking each one’s health before use.

```ts
import {
  RoundRobinRoutingStrategy,
  PingRoutingStrategy,
  NetworkGatewaysProvider,
} from "@ar.io/wayfinder-core";
import { ARIO } from '@ar.io/sdk';

// use static gateways
const strategy = new PingRoutingStrategy({
  routingStrategy: new RoundRobinRoutingStrategy({
    gateways: [new URL("https://gw1"), new URL("https://gw2")],
  }),
});

// use a dynamic list of gateways from the ARIO Network
const strategy2 = new PingRoutingStrategy({
  routingStrategy: new RoundRobinRoutingStrategy({
    gatewaysProvider: new NetworkGatewaysProvider({
      ario: ARIO.mainnet(),
      sortBy: 'operatorStake',
      limit: 5,
    }),
  }),
});
```

#### Cache around any composed strategy

Because `SimpleCacheRoutingStrategy` accepts any `RoutingStrategy`, you can
cache more complex compositions too.

```ts
// use a dynamic list of gateways from the ARIO Network
const randomStrategy = new RandomRoutingStrategy({
  gatewaysProvider: new NetworkGatewaysProvider({
    ario: ARIO.mainnet(),
    sortBy: 'operatorStake',
    limit: 20,
  }),
});

// wrap the random strategy with a ping strategy
const pingRandom = new PingRoutingStrategy({
  routingStrategy: randomStrategy,
});

// wrap the ping random strategy with a cache strategy, caching the selected gateway for 10 minutes
const cachedStrategy = new SimpleCacheRoutingStrategy({
  routingStrategy: pingRandom,
  ttlSeconds: 600,
});
```

In all cases, you can supply the composed strategy to `Wayfinder` (or whatever
router factory you use) and pass in a gateways provider:

```ts
import { Wayfinder, StaticGatewaysProvider } from "@ar.io/wayfinder-core";

const router = new Wayfinder({
  gatewaysProvider: new StaticGatewaysProvider({
    gateways: [new URL("https://gw1"), new URL("https://gw2")],
  }),
  routingStrategy: strategy, // any of the compositions above
});
```